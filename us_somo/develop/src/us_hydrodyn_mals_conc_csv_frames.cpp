// ---------------------------------------------------------------------------------------------
// --------------- WARNING: this code is generated by an automatic code generator --------------
// ---------------------------------------------------------------------------------------------
// -------------- WARNING: any modifications made to this code will be overwritten -------------
// ---------------------------------------------------------------------------------------------

#include "../include/us_hydrodyn_mals_conc_csv_frames.h"
//Added by qt3to4:
#include <QHBoxLayout>
#include <QCloseEvent>
#include <QGridLayout>
#include <QFrame>
#include <QLabel>

US_Hydrodyn_Mals_Conc_Csv_Frames::US_Hydrodyn_Mals_Conc_Csv_Frames(
                                           void                     *              us_hydrodyn,
                                           map < QString, QString > *              parameters,
                                           QWidget *                               p,
                                           const char *                            
                                           ) : QDialog( p )
{
   this->us_hydrodyn                          = us_hydrodyn;
   this->parameters                           = parameters;

   USglobal = new US_Config();
   setPalette( PALET_FRAME );
   setWindowTitle( us_tr( "US-SOMO MALS: Concentration CSV Time -> Frame conversion" ) );

   setupGUI();

   global_Xpos += 30;
   global_Ypos += 30;

   setGeometry( global_Xpos, global_Ypos, 0, 0 );
   setMinimumWidth( 600 );
}

US_Hydrodyn_Mals_Conc_Csv_Frames::~US_Hydrodyn_Mals_Conc_Csv_Frames()
{
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::cancel()
{
   parameters->clear( );
   close();
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::help()
{
   US_Help *online_help;
   online_help = new US_Help( this );
   online_help->show_help("manual/somo/mals_conc_csv_frames.html");
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::closeEvent( QCloseEvent *e )
{
   global_Xpos -= 30;
   global_Ypos -= 30;
   e->accept();
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::showhide( vector < QWidget * > & widgets, bool isChecked ) {
   for ( int i = 0; i < (int) widgets.size(); ++i ) {
      isChecked ? widgets[ i ]->show() : widgets[ i ]->hide();
   }
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::setupGUI()
{
   QGridLayout * background = new QGridLayout( this ); background->setContentsMargins( 0, 0, 0, 0 ); background->setSpacing( 0 );
   int row = 0;
   int col = 0;
   int colmax = 0;
   lbl_label_0 = new QLabel( us_tr( "Concentration CSV in Time to Frames conversion"), this);
   lbl_label_0->setFrameStyle(QFrame::WinPanel|QFrame::Raised);
   lbl_label_0->setAlignment(Qt::AlignCenter|Qt::AlignVCenter);
   lbl_label_0->setPalette( PALET_FRAME );
   lbl_label_0->setFont(QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1, QFont::Bold));

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_label_0 );
   
#endif

   col = 1 + 1;
   background->addWidget( lbl_label_0 , row , 0 , 1 + ( row ) - ( row ) , 1 + ( col++  ) - ( 0 ) );
   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }


   lbl_starttime = new QLabel( us_tr( " Data set starting time :" ), this );
   lbl_starttime->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_starttime->setPalette( PALET_LABEL );
   lbl_starttime->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_starttime );
   lbl_starttime->setToolTip( us_tr( "The starting time of the first point in dataset" ) );
#endif

   background->addWidget( lbl_starttime, row, col++ );

   le_starttime = new QLineEdit(this);
   le_starttime->setValidator( new QDoubleValidator( le_starttime ) );
   
   
   
   le_starttime->setText( parameters->count( "starttime" ) ? (*parameters)[ "starttime" ] : "" );
   le_starttime->setEnabled( true );
   le_starttime->setReadOnly( true );
   le_starttime->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_starttime->setPalette( PALET_NORMAL );
   connect( le_starttime, SIGNAL( textChanged( const QString & ) ), SLOT( update_starttime( const QString & )));

#if QT_VERSION > 0x040000
   le_starttime->setToolTip( us_tr( "The starting time of the first point in dataset" ) );
#endif

   background->addWidget( le_starttime, row, col++ );
   

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_endtime = new QLabel( us_tr( " Data set ending time :" ), this );
   lbl_endtime->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_endtime->setPalette( PALET_LABEL );
   lbl_endtime->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_endtime );
   lbl_endtime->setToolTip( us_tr( "The starting time of the last point in dataset" ) );
#endif

   background->addWidget( lbl_endtime, row, col++ );

   le_endtime = new QLineEdit(this);
   le_endtime->setValidator( new QDoubleValidator( le_endtime ) );
   
   
   
   le_endtime->setText( parameters->count( "endtime" ) ? (*parameters)[ "endtime" ] : "" );
   le_endtime->setEnabled( true );
   le_endtime->setReadOnly( true );
   le_endtime->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_endtime->setPalette( PALET_NORMAL );
   connect( le_endtime, SIGNAL( textChanged( const QString & ) ), SLOT( update_endtime( const QString & )));

#if QT_VERSION > 0x040000
   le_endtime->setToolTip( us_tr( "The starting time of the last point in dataset" ) );
#endif

   background->addWidget( le_endtime, row, col++ );
   

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_pointcount = new QLabel( us_tr( " Data set point count :" ), this );
   lbl_pointcount->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_pointcount->setPalette( PALET_LABEL );
   lbl_pointcount->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_pointcount );
   lbl_pointcount->setToolTip( us_tr( "The number of points in dataset" ) );
#endif

   background->addWidget( lbl_pointcount, row, col++ );

   le_pointcount = new QLineEdit(this);
   le_pointcount->setValidator( new QDoubleValidator( le_pointcount ) );
   
   
   
   le_pointcount->setText( parameters->count( "pointcount" ) ? (*parameters)[ "pointcount" ] : "" );
   le_pointcount->setEnabled( true );
   le_pointcount->setReadOnly( true );
   le_pointcount->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_pointcount->setPalette( PALET_NORMAL );
   connect( le_pointcount, SIGNAL( textChanged( const QString & ) ), SLOT( update_pointcount( const QString & )));

#if QT_VERSION > 0x040000
   le_pointcount->setToolTip( us_tr( "The number of points in dataset" ) );
#endif

   background->addWidget( le_pointcount, row, col++ );
   

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_frame1t = new QLabel( us_tr( " Frame number 1 time [minutes] :" ), this );
   lbl_frame1t->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_frame1t->setPalette( PALET_LABEL );
   lbl_frame1t->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_frame1t );
   lbl_frame1t->setToolTip( us_tr( "Enter the time of frame 1" ) );
#endif

   background->addWidget( lbl_frame1t, row, col++ );

   le_frame1t = new QLineEdit(this);
   le_frame1t->setValidator( new QDoubleValidator( le_frame1t ) );
   
   
   
   le_frame1t->setText( parameters->count( "frame1t" ) ? (*parameters)[ "frame1t" ] : "" );
   le_frame1t->setEnabled( true );
   
   le_frame1t->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_frame1t->setPalette( PALET_NORMAL );
   connect( le_frame1t, SIGNAL( textChanged( const QString & ) ), SLOT( update_frame1t( const QString & )));

#if QT_VERSION > 0x040000
   le_frame1t->setToolTip( us_tr( "Enter the time of frame 1" ) );
#endif

   background->addWidget( le_frame1t, row, col++ );
   le_frame1t->setFocus();

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_time2frame = new QLabel( us_tr( " Length of frame [seconds] :" ), this );
   lbl_time2frame->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_time2frame->setPalette( PALET_LABEL );
   lbl_time2frame->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_time2frame );
   lbl_time2frame->setToolTip( us_tr( "Enter the time length of a frame" ) );
#endif

   background->addWidget( lbl_time2frame, row, col++ );

   le_time2frame = new QLineEdit(this);
   le_time2frame->setValidator( new QDoubleValidator( le_time2frame ) );
   ( (QDoubleValidator *)le_time2frame->validator() )->setBottom( 1e-09 );
   
   
   le_time2frame->setText( parameters->count( "time2frame" ) ? (*parameters)[ "time2frame" ] : "" );
   le_time2frame->setEnabled( true );
   
   le_time2frame->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_time2frame->setPalette( PALET_NORMAL );
   connect( le_time2frame, SIGNAL( textChanged( const QString & ) ), SLOT( update_time2frame( const QString & )));

#if QT_VERSION > 0x040000
   le_time2frame->setToolTip( us_tr( "Enter the time length of a frame" ) );
#endif

   background->addWidget( le_time2frame, row, col++ );
   

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   cb_startframe = new QCheckBox(this);
   cb_startframe->setText( us_tr( "Specify starting frame number to extract " ) );
   cb_startframe->setChecked( parameters->count( "startframe" ) ? ( (*parameters)[ "startframe" ] == "true" ? true : false ) : false );
   cb_startframe->setEnabled( true );
   cb_startframe->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   cb_startframe->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   AUTFBACK( cb_startframe );
   cb_startframe->setToolTip( us_tr( "Optionally specify the starting frame number to extract, default is frame number 1 if not checked" ) );
#endif

   connect( cb_startframe, SIGNAL( clicked() ), SLOT( set_startframe() ) );

   if ( col == 0 ) {
       background->addWidget( cb_startframe , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
       col = 2;
   } else {
       background->addWidget( cb_startframe, row, col++ );
   }

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_startframenumber = new QLabel( us_tr( " Starting frame number :" ), this );
   lbl_startframenumber->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_startframenumber->setPalette( PALET_LABEL );
   lbl_startframenumber->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_startframenumber );
   
#endif

   background->addWidget( lbl_startframenumber, row, col++ );

   le_startframenumber = new QLineEdit(this);
   le_startframenumber->setValidator( new QIntValidator( le_startframenumber ) );
   
   
   le_startframenumber->setText( parameters->count( "startframenumber" ) ? (*parameters)[ "startframenumber" ] : "" );
   le_startframenumber->setEnabled( true );
   le_startframenumber->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_startframenumber->setPalette( PALET_NORMAL );
   connect( le_startframenumber, SIGNAL( textChanged( const QString & ) ), SLOT( update_startframenumber( const QString & )));

#if QT_VERSION > 0x040000
   
#endif

   background->addWidget( le_startframenumber, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   repeats[ cb_startframe ].push_back( lbl_startframenumber ); repeats[ cb_startframe ].push_back( le_startframenumber );
   cb_endframe = new QCheckBox(this);
   cb_endframe->setText( us_tr( "Specify ending frame number to extract " ) );
   cb_endframe->setChecked( parameters->count( "endframe" ) ? ( (*parameters)[ "endframe" ] == "true" ? true : false ) : false );
   cb_endframe->setEnabled( true );
   cb_endframe->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   cb_endframe->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   AUTFBACK( cb_endframe );
   cb_endframe->setToolTip( us_tr( "Optionally specify the ending frame number to extract, default is last frame number available" ) );
#endif

   connect( cb_endframe, SIGNAL( clicked() ), SLOT( set_endframe() ) );

   if ( col == 0 ) {
       background->addWidget( cb_endframe , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
       col = 2;
   } else {
       background->addWidget( cb_endframe, row, col++ );
   }

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_endframenumber = new QLabel( us_tr( " Ending frame number :" ), this );
   lbl_endframenumber->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_endframenumber->setPalette( PALET_LABEL );
   lbl_endframenumber->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_endframenumber );
   
#endif

   background->addWidget( lbl_endframenumber, row, col++ );

   le_endframenumber = new QLineEdit(this);
   le_endframenumber->setValidator( new QIntValidator( le_endframenumber ) );
   
   
   le_endframenumber->setText( parameters->count( "endframenumber" ) ? (*parameters)[ "endframenumber" ] : "" );
   le_endframenumber->setEnabled( true );
   le_endframenumber->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_endframenumber->setPalette( PALET_NORMAL );
   connect( le_endframenumber, SIGNAL( textChanged( const QString & ) ), SLOT( update_endframenumber( const QString & )));

#if QT_VERSION > 0x040000
   
#endif

   background->addWidget( le_endframenumber, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   repeats[ cb_endframe ].push_back( lbl_endframenumber ); repeats[ cb_endframe ].push_back( le_endframenumber );
   pb_go = new QPushButton( us_tr( "Process" ), this );
   pb_go->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1 ) );
   pb_go->setPalette( PALET_PUSHB );
   connect( pb_go, SIGNAL( clicked() ), SLOT( go() ) );

#if QT_VERSION > 0x040000
   pb_go->setToolTip( us_tr( "Process" ) );
#endif

   if ( 0 == 10 ) {
       if ( col == 0 ) {
           background->addWidget( pb_go , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
           col = 2;
       } else {
           background->addWidget( pb_go, row, col++ );
       }

       if ( colmax < col ) {
          colmax = col;
       }

       if ( 0 == 0 ) {
          row++;
          col = 0;
       }
   } else {
       bottom_row_buttons.push_back( pb_go );
   }

   
   pb_help = new QPushButton(us_tr("Help"), this);
   pb_help->setFont(QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1));
   pb_help->setPalette( PALET_PUSHB );
   connect(pb_help, SIGNAL(clicked()), SLOT(help()));

   pb_cancel = new QPushButton(us_tr("Close"), this);
   pb_cancel->setText(us_tr("Cancel"));
   pb_cancel->setFont(QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1));
   pb_cancel->setPalette( PALET_PUSHB );
   connect(pb_cancel, SIGNAL(clicked()), SLOT(cancel()));

   {
      QHBoxLayout * hbl = new QHBoxLayout(); hbl->setContentsMargins( 0, 0, 0, 0 ); hbl->setSpacing( 0 );
      hbl->addWidget( pb_help );
      hbl->addWidget( pb_cancel );
      for ( int i = 0; i < (int) bottom_row_buttons.size(); ++i ) {
         hbl->addWidget( bottom_row_buttons[ i ] );
      }

      background->addLayout( hbl , row , 0 , 1 + ( row ) - ( row ) , 1 + ( colmax - 1  ) - ( 0 ) );
   }

   for ( map < QWidget *, vector < QWidget * > >::iterator it = repeats.begin();
         it != repeats.end();
         it++ ) {
      showhide( it->second, ((QCheckBox* )it->first)->isChecked() );
   }
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::update_starttime( const QString & str )
{
   (*parameters)[ "starttime" ] = str;
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::update_endtime( const QString & str )
{
   (*parameters)[ "endtime" ] = str;
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::update_pointcount( const QString & str )
{
   (*parameters)[ "pointcount" ] = str;
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::update_frame1t( const QString & str )
{
   (*parameters)[ "frame1t" ] = str;
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::update_time2frame( const QString & str )
{
   (*parameters)[ "time2frame" ] = str;
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::set_startframe()
{
   (*parameters)[ "startframe" ] = cb_startframe->isChecked() ? "true" : "false";
   showhide( repeats[ cb_startframe ], cb_startframe->isChecked() );
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::update_startframenumber( const QString & str )
{
   (*parameters)[ "startframenumber" ] = str;
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::set_endframe()
{
   (*parameters)[ "endframe" ] = cb_endframe->isChecked() ? "true" : "false";
   showhide( repeats[ cb_endframe ], cb_endframe->isChecked() );
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::update_endframenumber( const QString & str )
{
   (*parameters)[ "endframenumber" ] = str;
}

void US_Hydrodyn_Mals_Conc_Csv_Frames::go()
{
    (*parameters)[ "button" ] = "go";
    close();
}

