
#if __cplusplus >= 201103L
#define USE_RAND_RNG
#define USE_SPHERE_CENTERS_MODEL 
#define USE_NANOFLANN_SORT_SCM
#include <future>
#include <chrono>
#include "../include/us_hydrodyn_zeno.h"
#undef R
extern bool *zeno_stop_flag;
extern US_Hydrodyn *zeno_us_hydrodyn;
static bool static_is_cmdline;
static US_Udp_Msg * static_zeno_us_udp_msg;
static  std::promise < bool > *p0;

#include <fstream>
class zeno_fout {
public:
   zeno_fout( const char * fname ) { ofs.open( fname ); };
   ~zeno_fout() { if ( ofs.is_open() ) { ofs.close(); } };
   std::ofstream ofs;
};
extern zeno_fout* zeno_cxx_fout;

#include "../include/us_zeno_cxx.h"
zeno_fout *zeno_cxx_fout;
// *** START *** lex.cc ***
// Generated by Flexc++ V1.08.00 on Wed, 28 Sep 2016 16:13:25 -0400

#include <iostream>
#include <fstream>
#include <sstream>
#include <stdexcept>

// $insert class_ih
// inlined #include "Scanner.ih"


    // s_ranges__: use (unsigned) characters as index to obtain
    //           that character's range-number.
    //           The range for EOF is defined in a constant in the
    //           class header file
size_t const ScannerBase::s_ranges__[] =
{
     0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
     4, 4, 4, 4, 4, 4, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 8, 9,10,11,12,13,13,
    13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
    14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,16,17,
    18,19,20,21,22,23,24,24,25,26,27,28,29,30,31,32,33,34,35,36,36,37,38,38,38,
    38,38,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,
    39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,
    39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,
    39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,
    39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,39,
    39,39,39,39,39,40,
};

    // s_dfa__ contains the rows of *all* DFAs ordered by start state.
    // The enum class StartCondition__ is defined in the baseclass header
    // INITIAL is always 0.
    // Each entry defines the row to transit to if the column's
    // character range was sensed. Row numbers are relative to the
    // used DFA and d_dfaBase__ is set to the first row of the subset to use.
    // The row's final two values are begin and end indices in
    // s_rfc__[] (rule, flags and count), defining the state's rule details
int const ScannerBase::s_dfa__[][44] =
{
    // INITIAL
    {-1, 1, 1, 1,-1, 1, 2, 2, 3, 2, 3, 4, 5, 6, 2, 7, 8, 2, 2, 2,
          2, 2, 9, 2, 2, 2,10, 2, 2, 2, 2,11,12,13,14,15, 2, 2, 2,-1,
         -1,-1,   0, 0},  // 0
    {-1, 1, 1, 1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,   0, 1},  // 1
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,   1, 2},  // 2
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 4, 2, 6, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,   2, 3},  // 3
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2,16, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,   3, 4},  // 4
    {-1,-1,-1,-1,-1,-1, 2,17, 2, 2, 2, 2,18, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,   4, 5},  // 5
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2,16, 2, 6, 2, 2, 2, 2, 2,19,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,   5, 6},  // 6
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,20, 2, 2, 2, 2, 2,-1,
         -1,-1,   6, 7},  // 7
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
         21, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,   7, 8},  // 8
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,22,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,23, 2, 2, 2, 2,-1,
         -1,-1,   8, 9},  // 9
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2,24, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,   9,10},  // 10
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2,25, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  10,11},  // 11
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2,26, 2, 2, 2,27, 2, 2, 2, 2, 2,-1,
         -1,-1,  11,12},  // 12
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,28,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  12,13},  // 13
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2,29, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  13,14},  // 14
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2,30, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  14,15},  // 15
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2,16, 2, 2, 2, 2, 2,19,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  15,16},  // 16
    {-1,31,-1,31,31,31,17,32,17,17,17,17,17,17,17,17,17,17,17,17,
         17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,31,
         31,-1,  16,17},  // 17
    {-1,33,34,33,33,33,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
         18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,33,
         -1,-1,  17,18},  // 18
    {-1,-1,-1,-1,-1,-1, 2, 2,35, 2,35, 2, 2,36, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  18,19},  // 19
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2,37, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  19,20},  // 20
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  20,21},  // 21
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,38, 2, 2, 2, 2, 2,-1,
         -1,-1,  21,22},  // 22
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2,39, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  22,23},  // 23
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,40, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  23,24},  // 24
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2,41, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  24,25},  // 25
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2,42, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  25,26},  // 26
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  26,27},  // 27
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2,43, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  27,28},  // 28
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2,44, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  28,29},  // 29
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,45, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  29,30},  // 30
    {-1,31,-1,31,31,31,31,46,31,31,31,31,31,31,31,31,31,31,31,31,
         31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
         31,-1,  30,30},  // 31
    {-1,31,-1,31,31,31,17,32,17,17,17,17,47,17,17,17,17,17,17,17,
         17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,31,
         31,-1,  30,31},  // 32
    {-1,33,34,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
         33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
         -1,-1,  31,31},  // 33
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
         -1,-1,  31,32},  // 34
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2,36, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  32,33},  // 35
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2,36, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  33,34},  // 36
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2,48, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  34,35},  // 37
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2,49, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  35,36},  // 38
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2,50, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  36,37},  // 39
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,51, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  37,38},  // 40
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,52, 2, 2, 2, 2,-1,
         -1,-1,  38,39},  // 41
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,53,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  39,40},  // 42
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2,54, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  40,41},  // 43
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,55, 2, 2, 2, 2, 2,-1,
         -1,-1,  41,42},  // 44
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,56, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  42,43},  // 45
    {-1,31,-1,31,31,31,31,46,31,31,31,31,57,31,31,31,31,31,31,31,
         31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
         31,-1,  43,43},  // 46
    {-1,31,-1,31,31,31,17,32,17,17,17,17,17,17,17,17,17,17,17,17,
         17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,31,
         31,-1,  43,44},  // 47
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  44,45},  // 48
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,58, 2, 2, 2, 2, 2,-1,
         -1,-1,  45,46},  // 49
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,59, 2, 2, 2, 2, 2,-1,
         -1,-1,  46,47},  // 50
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  47,48},  // 51
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2,60, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  48,49},  // 52
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,61, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  49,50},  // 53
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  50,51},  // 54
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,62, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  51,52},  // 55
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2,63, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  52,53},  // 56
    {-1,31,-1,31,31,31,31,46,31,31,31,31,31,31,31,31,31,31,31,31,
         31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
         31,-1,  53,54},  // 57
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2,48, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  54,55},  // 58
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,64, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  55,56},  // 59
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,65, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  56,57},  // 60
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,66,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  57,58},  // 61
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  58,59},  // 62
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,67, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  59,60},  // 63
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  60,61},  // 64
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2,68, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  61,62},  // 65
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  62,63},  // 66
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2,69, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  63,64},  // 67
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  64,65},  // 68
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,70, 2, 2, 2, 2, 2,-1,
         -1,-1,  65,66},  // 69
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,71, 2,-1,
         -1,-1,  66,67},  // 70
    {-1,-1,-1,-1,-1,-1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
          2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,-1,
         -1,-1,  67,68},  // 71
};

    // The first value is the rule index
    // The second value is the FLAG: see the scannerbase.h file
    // 1: Final     4: Count        11: Final/BOL,Inc     
    // 2: Inc.      5: Final,Count  13: Final/BOL,Count
    // 3: Final,Inc 9: Final/BOL    
    // The third value is the LOP count value (valid for Count flags)
size_t const ScannerBase::s_rfc__[][3] =
{
//     R  F  C
     { 2, 1, 0},  // 0
     {15, 1, 0},  // 1
     {15, 1, 0},  // 2
     {15, 1, 0},  // 3
     {15, 1, 0},  // 4
     { 3, 1, 0},  // 5
     {15, 1, 0},  // 6
     {15, 1, 0},  // 7
     {15, 1, 0},  // 8
     {15, 1, 0},  // 9
     {15, 1, 0},  // 10
     { 5, 1, 0},  // 11
     {15, 1, 0},  // 12
     {15, 1, 0},  // 13
     {15, 1, 0},  // 14
     { 4, 1, 0},  // 15
     {15, 1, 0},  // 16
     {15, 1, 0},  // 17
     {15, 1, 0},  // 18
     {15, 1, 0},  // 19
     {14, 1, 0},  // 20
     {15, 1, 0},  // 21
     {15, 1, 0},  // 22
     {15, 1, 0},  // 23
     {15, 1, 0},  // 24
     {15, 1, 0},  // 25
     { 7, 1, 0},  // 26
     {15, 1, 0},  // 27
     {15, 1, 0},  // 28
     {15, 1, 0},  // 29
     {15, 1, 0},  // 30
     { 1, 1, 0},  // 31
     {15, 1, 0},  // 32
     { 4, 1, 0},  // 33
     {15, 1, 0},  // 34
     {15, 1, 0},  // 35
     {15, 1, 0},  // 36
     {15, 1, 0},  // 37
     {15, 1, 0},  // 38
     {15, 1, 0},  // 39
     {15, 1, 0},  // 40
     {15, 1, 0},  // 41
     {15, 1, 0},  // 42
     { 0, 1, 0},  // 43
     { 6, 1, 0},  // 44
     {15, 1, 0},  // 45
     {15, 1, 0},  // 46
     {12, 1, 0},  // 47
     {15, 1, 0},  // 48
     {15, 1, 0},  // 49
     {11, 1, 0},  // 50
     {15, 1, 0},  // 51
     {15, 1, 0},  // 52
     { 0, 1, 0},  // 53
     {15, 1, 0},  // 54
     {15, 1, 0},  // 55
     {15, 1, 0},  // 56
     {15, 1, 0},  // 57
     {10, 1, 0},  // 58
     {15, 1, 0},  // 59
     { 9, 1, 0},  // 60
     {15, 1, 0},  // 61
     { 5, 1, 0},  // 62
     {15, 1, 0},  // 63
     { 8, 1, 0},  // 64
     {15, 1, 0},  // 65
     {15, 1, 0},  // 66
     {13, 1, 0},  // 67
};

int const (*ScannerBase::s_dfaBase__[])[44] =
{
    s_dfa__ + 0,
};

size_t ScannerBase::s_istreamNr = 0;

// $insert inputImplementation
ScannerBase::Input::Input()
:
    d_in(0),
    d_lineNr(1)
{}

ScannerBase::Input::Input(std::istream *iStream, size_t lineNr)
:
    d_in(iStream),
    d_lineNr(lineNr)
{}

size_t ScannerBase::Input::get()
{
    switch (size_t ch = next())         // get the next input char
    {
        case '\n':
            ++d_lineNr;
            [[fallthrough]];
        // FALLING THROUGH

        default:
        return ch;
    }
}

size_t ScannerBase::Input::next()
{
    size_t ch;

    if (d_deque.empty())                    // deque empty: next char fm d_in
    {
        if (d_in == 0)
            return AT_EOF;
        ch = d_in->get();
        return *d_in ? ch : static_cast<size_t>(AT_EOF);
    }

    ch = d_deque.front();
    d_deque.pop_front();

    return ch;
}

void ScannerBase::Input::reRead(size_t ch)
{
    if (ch < 0x100)
    {
        if (ch == '\n')
            --d_lineNr;
        d_deque.push_front(ch);
    }
}

void ScannerBase::Input::reRead(std::string const &str, size_t fm)
{
    for (size_t idx = str.size(); idx-- > fm; )
        reRead(str[idx]);
}

ScannerBase::ScannerBase(std::istream &in, std::ostream &out)
:
    d_filename("-"),
    d_startCondition(StartCondition__::INITIAL),
    d_state(0),
    d_out(new std::ostream(out.rdbuf())),
    d_sawEOF(false),
    d_atBOL(true),
    d_tailCount(16, std::numeric_limits<size_t>::max()),
// $insert interactiveInit
    d_in(0),
    d_input(new std::istream(in.rdbuf())),
    d_dfaBase__(s_dfa__)
{}

void ScannerBase::switchStream__(std::istream &in, size_t lineNr)
{
    d_input.close();
    d_state = 0;
    d_input = Input(new std::istream(in.rdbuf()), lineNr);
    d_sawEOF = false;
    d_atBOL = true;
}


ScannerBase::ScannerBase(std::string const &infilename, std::string const &outfilename)
:
    d_filename(infilename),
    d_startCondition(StartCondition__::INITIAL),
    d_state(0),
    d_out(outfilename == "-"    ? new std::ostream(zeno_cxx_fout->ofs.rdbuf()) :
          outfilename == ""     ? new std::ostream(std::cerr.rdbuf()) :
                                  new std::ofstream(outfilename)),
    d_sawEOF(false),
    d_atBOL(true),
    d_tailCount(16, std::numeric_limits<size_t>::max()),
    d_input(new std::ifstream(infilename)),
    d_dfaBase__(s_dfa__)
{}

void ScannerBase::switchStreams(std::istream &in, std::ostream &out)
{
    switchStream__(in, 1);
    switchOstream(out);
}


void ScannerBase::switchOstream(std::ostream &out)
{
    *d_out << std::flush;
    d_out.reset(new std::ostream(out.rdbuf()));
}

// $insert debugFunctions
void ScannerBase::setDebug(bool /* onOff */)
{}

bool ScannerBase::debug() const
{
    return false;
}

void ScannerBase::redo(size_t nChars)
{
    size_t from = nChars >= length() ? 0 : length() - nChars;
    d_input.reRead(d_matched, from);
    d_matched.resize(from);
}

void ScannerBase::switchOstream(std::string const &outfilename)
{
    *d_out << std::flush;
    d_out.reset(
            outfilename == "-"    ? new std::ostream(zeno_cxx_fout->ofs.rdbuf()) :
            outfilename == ""     ? new std::ostream(std::cerr.rdbuf()) :
                                    new std::ofstream(outfilename));
}


void ScannerBase::switchIstream(std::string const &infilename)
{
    d_input.close();
    d_filename = infilename;
    d_input = Input(new std::ifstream(infilename));
    d_sawEOF = false;
    d_atBOL = true;
}

void ScannerBase::switchStreams(std::string const &infilename,
                           std::string const &outfilename)
{
    switchOstream(outfilename);
    switchIstream(infilename);
}

void ScannerBase::pushStream(std::istream  &istr)
{
    std::istream *streamPtr = new std::istream(istr.rdbuf());
    p_pushStream("(istream)", streamPtr);
}

void ScannerBase::pushStream(std::string const &name)
{
    std::istream *streamPtr = new std::ifstream(name);
    if (!*streamPtr)
    {
        delete streamPtr;
        throw std::runtime_error("Cannot read " + name);
    }
    p_pushStream(name, streamPtr);
}


void ScannerBase::p_pushStream(std::string const &name, std::istream *streamPtr)
{
    if (d_streamStack.size() == s_maxSizeofStreamStack__)
    {
        delete streamPtr;
        throw std::length_error("Max stream stack size exceeded");
    }

    d_streamStack.push_back(StreamStruct{d_filename, d_input});
    d_filename = name;
    d_input = Input(streamPtr);
    d_sawEOF = false;
    d_atBOL = true;
}


bool ScannerBase::popStream()
{
    d_input.close();

    if (d_streamStack.empty())
        return false;

    StreamStruct &top = d_streamStack.back();

    d_input =   top.pushedInput;
    d_filename = top.pushedName;
    d_streamStack.pop_back();
    d_sawEOF = false;

    return true;
}

ScannerBase::ActionType__ ScannerBase::actionType__(size_t range)
{
    d_nextState = d_dfaBase__[d_state][range];

    if (d_nextState != -1)                  // transition is possible
        return ActionType__::CONTINUE;

    if (atFinalState())                     // FINAL state reached
        return ActionType__::MATCH;

    if (d_matched.size())
        return ActionType__::ECHO_FIRST;    // no match, echo the 1st char

    return range != s_rangeOfEOF__ ? 
                ActionType__::ECHO_CH 
            : 
                ActionType__::RETURN;
}

void ScannerBase::accept(size_t nChars)          // old name: less
{
    if (nChars < d_matched.size())
    {
        d_input.reRead(d_matched, nChars);
        d_matched.resize(nChars);
    }
}

  // The size of d_matched is determined:
  //    The current state is a known final state (as determined by 
  // inspectRFCs__(), just prior to calling matched__). 
  //    The contents of d_matched are reduced to d_final's size or (if set)
  // to the LOP-rule's tail size.
void ScannerBase::determineMatchedSize(FinData const &final)
{
    size_t length = final.matchLen;
    if (final.tailCount != std::numeric_limits<size_t>::max())
        length -= final.tailCount;

    d_input.reRead(d_matched, length);      // reread the tail section
    d_matched.resize(length);               // return what's left
}

  // At this point a rule has been matched.  The next character is not part of
  // the matched rule and is sent back to the input.  The final match length
  // is determined, the index of the matched rule is determined, and then
  // d_atBOL is updated. Finally the rule index is returned.
size_t ScannerBase::matched__(size_t ch)
{
    d_input.reRead(ch);

    if (!d_atBOL)
        d_final.atBOL.rule = std::numeric_limits<size_t>::max();

    FinData &final = d_final.atBOL.rule == std::numeric_limits<size_t>::max() ? 
                            d_final.notAtBOL
                        :
                            d_final.atBOL;

    determineMatchedSize(final);

    d_atBOL = *d_matched.rbegin() == '\n';


    return final.rule;
}

size_t ScannerBase::getRange__(int ch)       // using int to prevent casts
{
    if (ch != AT_EOF)
        d_sawEOF = false;

// $insert caseCheck
    ch = tolower(ch);

    return ch == AT_EOF ? static_cast<size_t>(s_rangeOfEOF__) : s_ranges__[ch];
}

  // At this point d_nextState contains the next state and continuation is
  // possible. The just read char. is appended to d_match, and LOP counts
  // are updated.
void ScannerBase::continue__(int ch)
{
    d_state = d_nextState;

    if (ch != AT_EOF)
        d_matched += ch;
}

void ScannerBase::echoCh__(size_t ch)
{
    *d_out << static_cast<char>(ch);
    d_atBOL = ch == '\n';
}


   // At this point there is no continuation. The last character is
   // pushed back into the input stream as well as all but the first char. in
   // the buffer. The first char. in the buffer is echoed to stderr. 
   // If there isn't any 1st char yet then the current char doesn't fit any
   // rules and that char is then echoed
void ScannerBase::echoFirst__(size_t ch)
{
    d_input.reRead(ch);
    d_input.reRead(d_matched, 1);
    echoCh__(d_matched[0]);
}

    // Inspect all s_rfc__ elements associated with the current state
    //  If the s_rfc__ element has its COUNT flag set then set the 
    // d_tailCount[rule] value to the element's tailCount value, if it has its 
    // INCREMENT flag set then increment d_tailCount[rule]
    //  If neither was set set the d_tailCount[rule] to numeric_limits<size_t>::max()
    // 
    // If the s_rfc__ element has its FINAL flag set then store the rule number
    // in d_final.second. If it has its FINAL + BOL flags set then store the
    // rule number in d_final.first
void ScannerBase::inspectRFCs__()
{
    for 
    (
        size_t begin = d_dfaBase__[d_state][s_finacIdx__], 
                 end = d_dfaBase__[d_state][s_finacIdx__ + 1];
            begin != end;
                ++begin
    )
    {
        size_t const *rfc = s_rfc__[begin];
        size_t flag = rfc[FLAGS];
        size_t rule = rfc[RULE];

        if (flag & INCREMENT)
            ++d_tailCount[rule];
        else 
            d_tailCount[rule] = (flag & COUNT) ? rfc[ACCCOUNT] : std::numeric_limits<size_t>::max();

        if (flag & FINAL)
        {
            FinData &final = (flag & BOL) ? d_final.atBOL : d_final.notAtBOL;
            final = FinData { rule, d_matched.size(), d_tailCount[rule] };
        }
    }
}

void ScannerBase::reset__()
{
    d_final = Final { {std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max() }, 
                      {std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max(), std::numeric_limits<size_t>::max() } };
    d_state = 0;
    d_return = true;

    if (!d_more)
        d_matched.clear( );

    d_more = false;
}

int Scanner::executeAction__(size_t ruleIdx)
try
{
    switch (ruleIdx)
    {
        // $insert actions
        case 3:
        {
#line 8 "lexer"
            return Parser::INT;

        }
        break;
        case 4:
        {
#line 9 "lexer"
            return Parser::FLOAT;

        }
        break;
        case 5:
        {
#line 10 "lexer"
            return Parser::SPHERE;

        }
        break;
        case 6:
        {
#line 11 "lexer"
            return Parser::ATOM;

        }
        break;
        case 7:
        {
#line 12 "lexer"
            return Parser::ST;

        }
        break;
        case 8:
        {
#line 13 "lexer"
            return Parser::RLAUNCH;

        }
        break;
        case 9:
        {
#line 14 "lexer"
            return Parser::HUNITS;

        }
        break;
        case 10:
        {
#line 15 "lexer"
            return Parser::UNITS;

        }
        break;
        case 11:
        {
#line 16 "lexer"
            return Parser::TEMP;

        }
        break;
        case 12:
        {
#line 17 "lexer"
            return Parser::MASS;

        }
        break;
        case 13:
        {
#line 18 "lexer"
            return Parser::VISCOSITY;

        }
        break;
        case 14:
        {
#line 19 "lexer"
            return Parser::BF;

        }
        break;
        case 15:
        {
#line 20 "lexer"
            return Parser::STRING;

        }
        break;
    }
    noReturn__();
    return 0;
}
catch (Leave__ value)
{
    return static_cast<int>(value);
}

int Scanner::lex__()
{
    reset__();
    preCode();

    while (true)
    {
        size_t ch = get__();                // fetch next char
        size_t range = getRange__(ch);      // determine the range

        inspectRFCs__();                    // update d_tailCount values

        switch (actionType__(range))        // determine the action
        {
            case ActionType__::CONTINUE:
                continue__(ch);
            continue;

            case ActionType__::MATCH:
            {
                d_token__ = executeAction__(matched__(ch));
                if (return__())
                {
                    print();
                    postCode(PostEnum__::RETURN);
                    return d_token__;
                }
                break;
            }

            case ActionType__::ECHO_FIRST:
                echoFirst__(ch);
            break;

            case ActionType__::ECHO_CH:
                echoCh__(ch);
            break;

            case ActionType__::RETURN:
                if (!popStream())
                {
                     postCode(PostEnum__::END);
                     return 0;
                }
                postCode(PostEnum__::POP);
             continue;
        } // switch

        postCode(PostEnum__::WIP);

        reset__();
        preCode();
    } // while
}

void ScannerBase::print__() const
{
}



// *** END *** lex.cc ***

// *** START *** parse.cc ***
// Generated by Bisonc++ V4.05.00 on Wed, 28 Sep 2016 16:13:25 -0400

// $insert class.ih
// inlined #include "Parser.ih"

// The FIRST element of SR arrays shown below uses `d_type', defining the
// state's type, and `d_lastIdx' containing the last element's index. If
// d_lastIdx contains the REQ_TOKEN bitflag (see below) then the state needs
// a token: if in this state d_token__ is _UNDETERMINED_, nextToken() will be
// called

// The LAST element of SR arrays uses `d_token' containing the last retrieved
// token to speed up the (linear) seach.  Except for the first element of SR
// arrays, the field `d_action' is used to determine what to do next. If
// positive, it represents the next state (used with SHIFT); if zero, it
// indicates `ACCEPT', if negative, -d_action represents the number of the
// rule to reduce to.

// `lookup()' tries to find d_token__ in the current SR array. If it fails, and
// there is no default reduction UNEXPECTED_TOKEN__ is thrown, which is then
// caught by the error-recovery function.

// The error-recovery function will pop elements off the stack until a state
// having bit flag ERR_ITEM is found. This state has a transition on _error_
// which is applied. In this _error_ state, while the current token is not a
// proper continuation, new tokens are obtained by nextToken(). If such a
// token is found, error recovery is successful and the token is
// handled according to the error state's SR table and parsing continues.
// During error recovery semantic actions are ignored.

// A state flagged with the DEF_RED flag will perform a default
// reduction if no other continuations are available for the current token.

// The ACCEPT STATE never shows a default reduction: when it is reached the
// parser returns ACCEPT(). During the grammar
// analysis phase a default reduction may have been defined, but it is
// removed during the state-definition phase.

// So:
//      s_x[] = 
//      {
//                  [_field_1_]         [_field_2_]
//
// First element:   {state-type,        idx of last element},
// Other elements:  {required token,    action to perform},
//                                      ( < 0: reduce, 
//                                          0: ACCEPT,
//                                        > 0: next state)
// Last element:    {set to d_token__,    action to perform}
//      }

// When the --thread-safe option is specified, all static data are defined as
// const. If --thread-safe is not provided, the state-tables are not defined
// as const, since the lookup() function below will modify them


namespace // anonymous
{
    char const author[] = "Frank B. Brokken (f.b.brokken@rug.nl)";

    enum 
    {
        STACK_EXPANSION = 5     // size to expand the state-stack with when
                                // full
    };

    enum ReservedTokens
    {
        PARSE_ACCEPT     = 0,   // `ACCEPT' TRANSITION
        _UNDETERMINED_   = -2,
        _EOF_            = -1,
        _error_          = 256
    };
    enum StateType       // modify statetype/data.cc when this enum changes
    {
        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
    };    
    struct PI__     // Production Info
    {
        size_t d_nonTerm; // identification number of this production's
                            // non-terminal 
        size_t d_size;    // number of elements in this production 
    };

    struct SR__     // Shift Reduce info, see its description above
    {
        union
        {
            int _field_1_;      // initializer, allowing initializations 
                                // of the SR s_[] arrays
            int d_type;
            int d_token;
        };
        union
        {
            int _field_2_;

            int d_lastIdx;          // if negative, the state uses SHIFT
            int d_action;           // may be negative (reduce), 
                                    // postive (shift), or 0 (accept)
            size_t d_errorState;    // used with Error states
        };
    };

    // $insert staticdata
    
// Productions Info Records:
PI__ const s_productionInfo[] = 
{
     {0, 0}, // not used: reduction values are negative
     {272, 0}, // 1: lines ->  <empty>
     {272, 2}, // 2: lines ->  line lines
     {273, 1}, // 3: line ->  sphereDef
     {273, 1}, // 4: line ->  atomDef
     {273, 1}, // 5: line ->  parameter
     {274, 5}, // 6: sphereDef (SPHERE) ->  SPHERE real real real real
     {275, 11}, // 7: atomDef (ATOM) ->  ATOM INT STRING STRING STRING INT real real real real real
     {275, 10}, // 8: atomDef (ATOM) ->  ATOM INT STRING STRING INT real real real real real
     {276, 2}, // 9: parameter (ST) ->  ST real
     {276, 2}, // 10: parameter (RLAUNCH) ->  RLAUNCH real
     {276, 3}, // 11: parameter (HUNITS) ->  HUNITS real string
     {276, 2}, // 12: parameter (UNITS) ->  UNITS string
     {276, 3}, // 13: parameter (TEMP) ->  TEMP real string
     {276, 3}, // 14: parameter (MASS) ->  MASS real string
     {276, 3}, // 15: parameter (VISCOSITY) ->  VISCOSITY real string
     {276, 2}, // 16: parameter (BF) ->  BF real
     {277, 1}, // 17: real (FLOAT) ->  FLOAT
     {277, 1}, // 18: real (INT) ->  INT
     {278, 1}, // 19: string (STRING) ->  STRING
     {279, 1}, // 20: lines_$ ->  lines
};

// State info and SR__ transitions for each state.


SR__ s_0[] =
{
    { { REQ_DEF}, { 16} },             
    { {     272}, {  1} }, // lines    
    { {     273}, {  2} }, // line     
    { {     274}, {  3} }, // sphereDef
    { {     275}, {  4} }, // atomDef  
    { {     276}, {  5} }, // parameter
    { {     259}, {  6} }, // SPHERE   
    { {     260}, {  7} }, // ATOM     
    { {     261}, {  8} }, // ST       
    { {     262}, {  9} }, // RLAUNCH  
    { {     263}, { 10} }, // HUNITS   
    { {     264}, { 11} }, // UNITS    
    { {     265}, { 12} }, // TEMP     
    { {     266}, { 13} }, // MASS     
    { {     267}, { 14} }, // VISCOSITY
    { {     268}, { 15} }, // BF       
    { {       0}, { -1} },             
};

SR__ s_1[] =
{
    { { REQ_TOKEN}, {            2} }, 
    { {     _EOF_}, { PARSE_ACCEPT} }, 
    { {         0}, {            0} }, 
};

SR__ s_2[] =
{
    { { REQ_DEF}, { 16} },             
    { {     272}, { 16} }, // lines    
    { {     273}, {  2} }, // line     
    { {     274}, {  3} }, // sphereDef
    { {     275}, {  4} }, // atomDef  
    { {     276}, {  5} }, // parameter
    { {     259}, {  6} }, // SPHERE   
    { {     260}, {  7} }, // ATOM     
    { {     261}, {  8} }, // ST       
    { {     262}, {  9} }, // RLAUNCH  
    { {     263}, { 10} }, // HUNITS   
    { {     264}, { 11} }, // UNITS    
    { {     265}, { 12} }, // TEMP     
    { {     266}, { 13} }, // MASS     
    { {     267}, { 14} }, // VISCOSITY
    { {     268}, { 15} }, // BF       
    { {       0}, { -1} },             
};

SR__ s_3[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -3} }, 
};

SR__ s_4[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -4} }, 
};

SR__ s_5[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -5} }, 
};

SR__ s_6[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 17} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_7[] =
{
    { { REQ_TOKEN}, {  2} },       
    { {       257}, { 20} }, // INT
    { {         0}, {  0} },       
};

SR__ s_8[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 21} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_9[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 22} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_10[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 23} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_11[] =
{
    { { REQ_TOKEN}, {  3} },          
    { {       278}, { 24} }, // string
    { {       269}, { 25} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_12[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 26} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_13[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 27} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_14[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 28} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_15[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 29} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_16[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -2} }, 
};

SR__ s_17[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 30} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_18[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -17} }, 
};

SR__ s_19[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -18} }, 
};

SR__ s_20[] =
{
    { { REQ_TOKEN}, {  2} },          
    { {       269}, { 31} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_21[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -9} }, 
};

SR__ s_22[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -10} }, 
};

SR__ s_23[] =
{
    { { REQ_TOKEN}, {  3} },          
    { {       278}, { 32} }, // string
    { {       269}, { 25} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_24[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -12} }, 
};

SR__ s_25[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -19} }, 
};

SR__ s_26[] =
{
    { { REQ_TOKEN}, {  3} },          
    { {       278}, { 33} }, // string
    { {       269}, { 25} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_27[] =
{
    { { REQ_TOKEN}, {  3} },          
    { {       278}, { 34} }, // string
    { {       269}, { 25} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_28[] =
{
    { { REQ_TOKEN}, {  3} },          
    { {       278}, { 35} }, // string
    { {       269}, { 25} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_29[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -16} }, 
};

SR__ s_30[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 36} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_31[] =
{
    { { REQ_TOKEN}, {  2} },          
    { {       269}, { 37} }, // STRING
    { {         0}, {  0} },          
};

SR__ s_32[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -11} }, 
};

SR__ s_33[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -13} }, 
};

SR__ s_34[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -14} }, 
};

SR__ s_35[] =
{
    { { DEF_RED}, {   1} }, 
    { {       0}, { -15} }, 
};

SR__ s_36[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 38} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_37[] =
{
    { { REQ_TOKEN}, {  3} },          
    { {       269}, { 39} }, // STRING
    { {       257}, { 40} }, // INT   
    { {         0}, {  0} },          
};

SR__ s_38[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -6} }, 
};

SR__ s_39[] =
{
    { { REQ_TOKEN}, {  2} },       
    { {       257}, { 41} }, // INT
    { {         0}, {  0} },       
};

SR__ s_40[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 42} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_41[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 43} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_42[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 44} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_43[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 45} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_44[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 46} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_45[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 47} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_46[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 48} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_47[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 49} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_48[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 50} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_49[] =
{
    { { REQ_TOKEN}, {  4} },         
    { {       277}, { 51} }, // real 
    { {       258}, { 18} }, // FLOAT
    { {       257}, { 19} }, // INT  
    { {         0}, {  0} },         
};

SR__ s_50[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -8} }, 
};

SR__ s_51[] =
{
    { { DEF_RED}, {  1} }, 
    { {       0}, { -7} }, 
};


// State array:
SR__ *s_state[] =
{
  s_0,  s_1,  s_2,  s_3,  s_4,  s_5,  s_6,  s_7,  s_8,  s_9,
  s_10,  s_11,  s_12,  s_13,  s_14,  s_15,  s_16,  s_17,  s_18,  s_19,
  s_20,  s_21,  s_22,  s_23,  s_24,  s_25,  s_26,  s_27,  s_28,  s_29,
  s_30,  s_31,  s_32,  s_33,  s_34,  s_35,  s_36,  s_37,  s_38,  s_39,
  s_40,  s_41,  s_42,  s_43,  s_44,  s_45,  s_46,  s_47,  s_48,  s_49,
  s_50,  s_51,
};

} // anonymous namespace ends



// If the parsing function call uses arguments, then provide an overloaded
// function.  The code below doesn't rely on parameters, so no arguments are
// required.  Furthermore, parse uses a function try block to allow us to do
// ACCEPT and ABORT from anywhere, even from within members called by actions,
// simply throwing the appropriate exceptions.

ParserBase::ParserBase()
:
    d_stackIdx__(-1),
    // $insert debuginit
    d_debug__(false),
    d_nErrors__(0),
    // $insert requiredtokens
    d_requiredTokens__(0),
    d_acceptedTokens__(d_requiredTokens__),
    d_token__(_UNDETERMINED_),
    d_nextToken__(_UNDETERMINED_)
{}


void Parser::print__()
{
// $insert print
}

void ParserBase::clearin()
{
    d_token__ = d_nextToken__ = _UNDETERMINED_;
}

void ParserBase::push__(size_t state)
{
    if (static_cast<size_t>(d_stackIdx__ + 1) == d_stateStack__.size())
    {
        size_t newSize = d_stackIdx__ + STACK_EXPANSION;
        d_stateStack__.resize(newSize);
        d_valueStack__.resize(newSize);
    }
    ++d_stackIdx__;
    d_stateStack__[d_stackIdx__] = d_state__ = state;
    *(d_vsp__ = &d_valueStack__[d_stackIdx__]) = d_val__;
}

void ParserBase::popToken__()
{
    d_token__ = d_nextToken__;

    d_val__ = d_nextVal__;
    d_nextVal__ = STYPE__();

    d_nextToken__ = _UNDETERMINED_;
}
     
void ParserBase::pushToken__(int token)
{
    d_nextToken__ = d_token__;
    d_nextVal__ = d_val__;
    d_token__ = token;
}
     
void ParserBase::pop__(size_t count)
{
    if (d_stackIdx__ < static_cast<int>(count))
    {
        ABORT();
    }

    d_stackIdx__ -= count;
    d_state__ = d_stateStack__[d_stackIdx__];
    d_vsp__ = &d_valueStack__[d_stackIdx__];
}

inline size_t ParserBase::top__() const
{
    return d_stateStack__[d_stackIdx__];
}

void Parser::executeAction(int production)
try
{
    if (d_token__ != _UNDETERMINED_)
        pushToken__(d_token__);     // save an already available token

                                    // save default non-nested block $$
    if (int size = s_productionInfo[production].d_size)
        d_val__ = d_vsp__[1 - size];

    switch (production)
    {
        // $insert actioncases
        
        case 6:
#line 29 "grammar"
        {
         addSphere(d_vsp__[-3].data<Tag__::FLOAT_TYPE>(), d_vsp__[-2].data<Tag__::FLOAT_TYPE>(), d_vsp__[-1].data<Tag__::FLOAT_TYPE>(), d_vsp__[0].data<Tag__::FLOAT_TYPE>());
         }
        break;

        case 7:
#line 37 "grammar"
        {
         addSphere(d_vsp__[-4].data<Tag__::FLOAT_TYPE>(), d_vsp__[-3].data<Tag__::FLOAT_TYPE>(), d_vsp__[-2].data<Tag__::FLOAT_TYPE>(), d_vsp__[0].data<Tag__::FLOAT_TYPE>());
         }
        break;

        case 8:
#line 43 "grammar"
        {
         addSphere(d_vsp__[-4].data<Tag__::FLOAT_TYPE>(), d_vsp__[-3].data<Tag__::FLOAT_TYPE>(), d_vsp__[-2].data<Tag__::FLOAT_TYPE>(), d_vsp__[0].data<Tag__::FLOAT_TYPE>());
         }
        break;

        case 9:
#line 50 "grammar"
        {
         setST(d_vsp__[0].data<Tag__::FLOAT_TYPE>());
         }
        break;

        case 10:
#line 55 "grammar"
        {
         setRLAUNCH(d_vsp__[0].data<Tag__::FLOAT_TYPE>());
         }
        break;

        case 11:
#line 60 "grammar"
        {
         setHUNITS(d_vsp__[-1].data<Tag__::FLOAT_TYPE>(), d_vsp__[0].data<Tag__::STRING_TYPE>());
         }
        break;

        case 12:
#line 65 "grammar"
        {
         setUNITS(d_vsp__[0].data<Tag__::STRING_TYPE>());
         }
        break;

        case 13:
#line 70 "grammar"
        {
         setTEMP(d_vsp__[-1].data<Tag__::FLOAT_TYPE>(), d_vsp__[0].data<Tag__::STRING_TYPE>());
         }
        break;

        case 14:
#line 75 "grammar"
        {
         setMASS(d_vsp__[-1].data<Tag__::FLOAT_TYPE>(), d_vsp__[0].data<Tag__::STRING_TYPE>());
         }
        break;

        case 15:
#line 80 "grammar"
        {
         setVISCOSITY(d_vsp__[-1].data<Tag__::FLOAT_TYPE>(), d_vsp__[0].data<Tag__::STRING_TYPE>());
         }
        break;

        case 16:
#line 85 "grammar"
        {
         setBF(d_vsp__[0].data<Tag__::FLOAT_TYPE>());
         }
        break;

        case 17:
#line 92 "grammar"
        {
         d_val__.get<Tag__::FLOAT_TYPE>() = stod(d_scanner.matched());
         }
        break;

        case 18:
#line 97 "grammar"
        {
         d_val__.get<Tag__::FLOAT_TYPE>() = stod(d_scanner.matched());
         }
        break;

        case 19:
#line 104 "grammar"
        {
         d_val__.get<Tag__::STRING_TYPE>() = d_scanner.matched();
         }
        break;

    }
}
catch (std::exception const &exc)
{
    exceptionHandler__(exc);
}

inline void ParserBase::reduce__(PI__ const &pi)
{
    d_token__ = pi.d_nonTerm;
    pop__(pi.d_size);

}

// If d_token__ is _UNDETERMINED_ then if d_nextToken__ is _UNDETERMINED_ another
// token is obtained from lex(). Then d_nextToken__ is assigned to d_token__.
void Parser::nextToken()
{
    if (d_token__ != _UNDETERMINED_)        // no need for a token: got one
        return;                             // already

    if (d_nextToken__ != _UNDETERMINED_)
    {
        popToken__();                       // consume pending token
    }
    else
    {
        ++d_acceptedTokens__;               // accept another token (see
                                            // errorRecover())
        d_token__ = lex();
        if (d_token__ <= 0)
            d_token__ = _EOF_;
    }
    print();
}

// if the final transition is negative, then we should reduce by the rule
// given by its positive value. Note that the `recovery' parameter is only
// used with the --debug option
int Parser::lookup(bool recovery)
{
    // $insert threading
    SR__ *sr = s_state[d_state__];        // get the appropriate state-table
    int lastIdx = sr->d_lastIdx;        // sentinel-index in the SR__ array

    SR__ *lastElementPtr = sr + lastIdx;
    SR__ *elementPtr = sr + 1;            // start the search at s_xx[1]

    lastElementPtr->d_token = d_token__;// set search-token

    while (elementPtr->d_token != d_token__)
        ++elementPtr;

    if (elementPtr == lastElementPtr)   // reached the last element
    {
        if (elementPtr->d_action < 0)   // default reduction
        {
            return elementPtr->d_action;                
        }

        // No default reduction, so token not found, so error.
        throw UNEXPECTED_TOKEN__;
    }

    // not at the last element: inspect the nature of the action
    // (< 0: reduce, 0: ACCEPT, > 0: shift)

    int action = elementPtr->d_action;


    return action;
}

    // When an error has occurred, pop elements off the stack until the top
    // state has an error-item. If none is found, the default recovery
    // mode (which is to abort) is activated. 
    //
    // If EOF is encountered without being appropriate for the current state,
    // then the error recovery will fall back to the default recovery mode.
    // (i.e., parsing terminates)
void Parser::errorRecovery()
try
{
    if (d_acceptedTokens__ >= d_requiredTokens__)// only generate an error-
    {                                           // message if enough tokens 
        ++d_nErrors__;                          // were accepted. Otherwise
        error("Syntax error");                  // simply skip input

    }


    // get the error state
    while (not (s_state[top__()][0].d_type & ERR_ITEM))
    {
        pop__();
    }

    // In the error state, lookup a token allowing us to proceed.
    // Continuation may be possible following multiple reductions,
    // but eventuall a shift will be used, requiring the retrieval of
    // a terminal token. If a retrieved token doesn't match, the catch below 
    // will ensure the next token is requested in the while(true) block
    // implemented below:

    int lastToken = d_token__;                  // give the unexpected token a
                                                // chance to be processed
                                                // again.

    pushToken__(_error_);                       // specify _error_ as next token
    push__(lookup(true));                       // push the error state

    d_token__ = lastToken;                      // reactivate the unexpected
                                                // token (we're now in an
                                                // ERROR state).

    bool gotToken = true;                       // the next token is a terminal

    while (true)
    {
        try
        {
            if (s_state[d_state__]->d_type & REQ_TOKEN)
            {
                gotToken = d_token__ == _UNDETERMINED_;
                nextToken();                    // obtain next token
            }
            
            int action = lookup(true);

            if (action > 0)                 // push a new state
            {
                push__(action);
                popToken__();

                if (gotToken)
                {

                    d_acceptedTokens__ = 0;
                    return;
                }
            }
            else if (action < 0)
            {
                // no actions executed on recovery but save an already 
                // available token:
                if (d_token__ != _UNDETERMINED_)
                    pushToken__(d_token__);
 
                                            // next token is the rule's LHS
                reduce__(s_productionInfo[-action]); 
            }
            else
                ABORT();                    // abort when accepting during
                                            // error recovery
        }
        catch (...)
        {
            if (d_token__ == _EOF_)
                ABORT();                    // saw inappropriate _EOF_
                      
            popToken__();                   // failing token now skipped
        }
    }
}
catch (ErrorRecovery__)       // This is: DEFAULT_RECOVERY_MODE
{
    ABORT();
}

    // The parsing algorithm:
    // Initially, state 0 is pushed on the stack, and d_token__ as well as
    // d_nextToken__ are initialized to _UNDETERMINED_. 
    //
    // Then, in an eternal loop:
    //
    //  1. If a state does not have REQ_TOKEN no token is assigned to
    //     d_token__. If the state has REQ_TOKEN, nextToken() is called to
    //      determine d_nextToken__ and d_token__ is set to
    //     d_nextToken__. nextToken() will not call lex() unless d_nextToken__ is 
    //     _UNDETERMINED_. 
    //
    //  2. lookup() is called: 
    //     d_token__ is stored in the final element's d_token field of the
    //     state's SR_ array. 
    //
    //  3. The current token is looked up in the state's SR_ array
    //
    //  4. Depending on the result of the lookup() function the next state is
    //     shifted on the parser's stack, a reduction by some rule is applied,
    //     or the parsing function returns ACCEPT(). When a reduction is
    //     called for, any action that may have been defined for that
    //     reduction is executed.
    //
    //  5. An error occurs if d_token__ is not found, and the state has no
    //     default reduction. Error handling was described at the top of this
    //     file.

int Parser::parse()
try 
{
    push__(0);                              // initial state
    clearin();                              // clear the tokens.

    while (true)
    {
        try
        {
            if (s_state[d_state__]->d_type & REQ_TOKEN)
                nextToken();                // obtain next token


            int action = lookup(false);     // lookup d_token__ in d_state__

            if (action > 0)                 // SHIFT: push a new state
            {
                push__(action);
                popToken__();               // token processed
            }
            else if (action < 0)            // REDUCE: execute and pop.
            {
                executeAction(-action);
                                            // next token is the rule's LHS
                reduce__(s_productionInfo[-action]); 
            }
            else 
                ACCEPT();
        }
        catch (ErrorRecovery__)
        {
            errorRecovery();
        }
    }
}
catch (Return__ retValue)
{
    return retValue;
}

// $insert polymorphicImpl
namespace Meta__
{
   Base::~Base()
   {}
}





// *** END *** parse.cc ***

// *** START *** Main.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Mon Feb 24 11:25:18 2014 EDT
//
// Time-stamp: <2016-09-28 12:08:25 dcj>
//
// ================================================================

#ifdef USE_MPI
#include <mpi.h>
#endif

#include <thread>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <limits>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <ctime>

// inlined #include "Parameters.h"
// inlined #include "Units.h"
// inlined #include "Uncertain.h"

// inlined #include "Parser.h"

// inlined #include "ResultsZeno.h"
// inlined #include "ResultsInterior.h"
// inlined #include "ResultsCompiler.h"

// inlined #include "Geometry/Sphere.h"
// inlined #include "Geometry/Spheres.h"
// inlined #include "Geometry/Vector3.h"

// inlined #include "NearestSurfacePoint/PointFromSphereCenters.h"

// inlined #include "InsideOutside/InOutSphereCenters.h"

// inlined #include "BoundingSphere/BoundingSphereAABB.h"

// inlined #include "SpherePoint/RandomSpherePointMarsaglia.h"
// inlined #include "SpherePoint/BiasedSpherePointDirect.h"
// inlined #include "SpherePoint/RandomBallPointRejection.h"

// inlined #include "Walker/WalkerExterior.h"
// inlined #include "Walker/SamplerInterior.h"

// inlined #include "Timer.h"

// inlined #include "SphereCenterModel/NanoFLANNSort.h"

// inlined #include "RandomNumber/SPRNG.h"

using SpheresModel = NanoFLANNSort;

using SpheresNearestSurfacePointFinder = PointFromSphereCenters<SpheresModel>;
using SpheresInsideOutsideTester       = InOutSphereCenters<SpheresModel>;

using RandomNumberGenerator = Rand;

using BoundingSphereGenerator = 
  BoundingSphereAABB<double>;

using RandomSpherePointGenerator = 
  RandomSpherePointMarsaglia<double, 
			     RandomNumberGenerator>;

using BiasedSpherePointGenerator = 
  BiasedSpherePointDirect<double, 
			  RandomNumberGenerator, 
			  RandomSpherePointGenerator>;

using RandomBallPointGenerator =
  RandomBallPointRejection<double,
			   RandomNumberGenerator>;

// ================================================================

int
getInput(int argc, char **argv,
	 Parameters * parameters,
	 long long * numWalksInProcess,
	 long long * numSamplesInProcess,
	 Spheres<double> * spheres,
	 bool * spheresLoaded,
	 double * initializeTime,
	 double * readTime,
	 double * broadcastTime);

int
preprocessWalkOnSpheres(bool spheresLoaded,
			Parameters const & parameters,
			Spheres<double> const & spheres,
			Sphere<double> * boundingSphere,
			SpheresModel * spheresModel,
			SpheresNearestSurfacePointFinder * *
			spheresNearestSurfacePointFinder,
			double * preprocessTime);

void setupRNGs(Parameters const & parameters,
	       std::vector<RandomNumberGenerator> * threadRNGs);

int
getWalkOnSpheresResults(long long numWalksInProcess,			
			Parameters const & parameters,
			Sphere<double> const & boundingSphere,
			SpheresNearestSurfacePointFinder const * 
			spheresNearestSurfacePointFinder,			
			std::vector<RandomNumberGenerator> * threadRNGs,
			ResultsZeno * * resultsZeno,
			double * walkTime,
			double * reduceTime);

int
preprocessInterior(bool spheresLoaded,
		   Parameters const & parameters,
		   SpheresModel const & spheresModel,
		   SpheresInsideOutsideTester * *
		   spheresInsideOutsideTester,
		   double * surfacePreprocessTime);

int
getInteriorResults(long long numSamplesInProcess,			
		   Parameters const & parameters,
		   Sphere<double> const & boundingSphere,
		   SpheresInsideOutsideTester const * 
		   spheresInsideOutsideTester,			
		   std::vector<RandomNumberGenerator> * threadRNGs,
		   ResultsInterior * * resultsInterior,
		   double * sampleTime,
		   double * volumeReduceTime);

long long 
computeNumInProcess(int mpiSize, int mpiRank,
		    long long totalNumSamples);

void
parseBodFile(Parameters * parameters, 
	     Spheres<double> * spheres);

void
getBodData(Parameters * parameters,
	   Spheres<double> * spheres,
	   double * readTime,
	   double * broadcastTime);

void
computeDefaultParameters(Parameters * parameters,
			 Sphere<double> * boundingSphere);

long long 
estimateTotalNum(double requestedError,
		 long long numSoFar,
		 Uncertain<double> const & currentValue);

void 
doWalkOnSpheresSelector(Parameters const & parameters,
			long long numWalksInProcess,
			Sphere<double> const & boundingSphere, 
			SpheresNearestSurfacePointFinder const * 
			spheresNearestSurfacePointFinder,
			std::vector<RandomNumberGenerator> * threadRNGs,
			ResultsZeno * resultsZeno,
			double * walkTime);

template <class NearestSurfacePointFinder>
void
doWalkOnSpheres(int numThreads,
		long long numWalksInProcess,
		Sphere<double> const & boundingSphere, 
		NearestSurfacePointFinder const & 
		nearestSurfacePointFinder,
		double fracErrorBound,
		double shellThickness,
		std::vector<RandomNumberGenerator> * threadRNGs,
		ResultsZeno * resultsZeno,
		double * walkTime);

template <class NearestSurfacePointFinder>
void
doWalkOnSpheresThread(Sphere<double> const & boundingSphere, 
		      NearestSurfacePointFinder const & 
		      nearestSurfacePointFinder,
		      int threadNum,
		      double fracErrorBound,
		      double shellThickness,
		      long long numWalks,
		      RandomNumberGenerator * randomNumberGenerator,
		      ResultsZeno * resultsZeno);

void
doInteriorSamplingSelector(Parameters const & parameters,
			   long long numSamplesInProcess,
			   Sphere<double> const & boundingSphere,
			   SpheresInsideOutsideTester const *  
			   spheresInsideOutsideTester,
			   std::vector<RandomNumberGenerator> * threadRNGs,
			   ResultsInterior * resultsInterior,
			   double * sampleTime);

template <class InsideOutsideTester>
void
doInteriorSampling(int numThreads,
		   long long numSamplesInProcess,
		   Sphere<double> const & boundingSphere, 
		   InsideOutsideTester const & insideOutsideTester,
		   double fracErrorBound,
		   std::vector<RandomNumberGenerator> * threadRNGs,
		   ResultsInterior * resultsInterior,
		   double * sampleTime);

template <class InsideOutsideTester>
void
doInteriorSamplingThread(Sphere<double> const & boundingSphere, 
			 InsideOutsideTester const & insideOutsideTester,
			 int threadNum,
			 double fracErrorBound,
			 long long numSamples,
			 RandomNumberGenerator * randomNumberGenerators,
			 ResultsInterior * resultsInterior);

void
printOutput(Sphere<double> const & boundingSphere,
	    ResultsInterior const * resultsInterior,
	    ResultsZeno const * resultsZeno,
	    Parameters const & parameters, 
	    double initializeTime,
	    double readTime,
	    double broadcastTime,
	    double preprocessTime,
	    double walkTime,
	    double reduceTime,
	    double surfacePreprocessTime,
	    double sampleTime,
	    double volumeReduceTime);

void
savePointFiles(ResultsInterior & resultsInterior,
	       ResultsZeno & resultsZeno,
	       Parameters const & parameters);

void
printTime(std::string const & label);

void
printRAM(std::string const & label);

void
writePoints(std::string const & fileName, 
	    std::vector<Vector3<double> > const * points,
	    std::vector<Vector3<char> > const * charges);

// ================================================================

int zeno_cxx_main(int argc, char **argv, const char * fname, bool is_cmdline, US_Udp_Msg  * zeno_us_udp_msg) { zeno_cxx_fout = new zeno_fout( fname );

  static_is_cmdline = is_cmdline;
  static_zeno_us_udp_msg = zeno_us_udp_msg;

  Timer totalTimer;

  totalTimer.start();

  Timer initializeTimer;

  initializeTimer.start();

  int mpiSize = 1, mpiRank = 0;

#ifdef USE_MPI
  MPI_Init(&argc, &argv);

  MPI_Comm_size(MPI_COMM_WORLD, &mpiSize);
  MPI_Comm_rank(MPI_COMM_WORLD, &mpiRank);
#endif

  if (mpiRank == 0) {
    printTime("Start time: ");
  }

  Parameters parameters;

  parameters.setMpiSize(mpiSize);
  parameters.setMpiRank(mpiRank);

  long long numWalksInProcess   = 0;
  long long numSamplesInProcess = 0;

  double initializeTime = 0;
  double readTime       = 0;
  double broadcastTime  = 0;

  Spheres<double> spheres;

  bool spheresLoaded = false;

  initializeTimer.stop();

  int getInputSuccess = 
    getInput(argc, argv,
	     &parameters,
	     &numWalksInProcess,
	     &numSamplesInProcess,
	     &spheres,
	     &spheresLoaded,
	     &initializeTime,
	     &readTime,
	     &broadcastTime);

  if (getInputSuccess != 0) {
    return getInputSuccess;
  }

  initializeTimer.start();

  SpheresModel spheresModel;

  SpheresNearestSurfacePointFinder * spheresNearestSurfacePointFinder = NULL;

  Sphere<double> boundingSphere;

  double preprocessTime = 0;

  initializeTimer.stop();

  int preprocessWalkOnSpheresSuccess = 
    preprocessWalkOnSpheres(spheresLoaded,
			    parameters,
			    spheres,
			    &boundingSphere,
			    &spheresModel,
			    &spheresNearestSurfacePointFinder,
			    &preprocessTime);

  if (preprocessWalkOnSpheresSuccess != 0) {
    return preprocessWalkOnSpheresSuccess;
  }

  initializeTimer.start();

  computeDefaultParameters(&parameters, &boundingSphere);

  std::vector<RandomNumberGenerator> threadRNGs;

  setupRNGs(parameters,
	    &threadRNGs);

  ResultsZeno * resultsZeno = NULL;

  double walkTime   = 0;
  double reduceTime = 0;

  initializeTimer.stop();

  int getWalkOnSpheresResultsSuccess = 
    getWalkOnSpheresResults(numWalksInProcess,			
			    parameters,
			    boundingSphere,
			    spheresNearestSurfacePointFinder,			
			    &threadRNGs,
			    &resultsZeno,
			    &walkTime,
			    &reduceTime);

  if (getWalkOnSpheresResultsSuccess != 0) {
    return getWalkOnSpheresResultsSuccess;
  }

  initializeTimer.start();

  SpheresInsideOutsideTester * spheresInsideOutsideTester = NULL;

  double surfacePreprocessTime = 0;

  initializeTimer.stop();

  int preprocessInteriorSuccess = 
    preprocessInterior(spheresLoaded,
		       parameters,
		       spheresModel,
		       &spheresInsideOutsideTester,
		       &surfacePreprocessTime);

  if (preprocessInteriorSuccess != 0) {
    return preprocessInteriorSuccess;
  }

  initializeTimer.start();

  ResultsInterior * resultsInterior = NULL;

  double sampleTime       = 0;
  double volumeReduceTime = 0;

  initializeTimer.stop();

  int getInteriorResultsSuccess = 
    getInteriorResults(numSamplesInProcess,			
		       parameters,
		       boundingSphere,
		       spheresInsideOutsideTester,			
		       &threadRNGs,
		       &resultsInterior,
		       &sampleTime,
		       &volumeReduceTime);

  if (getInteriorResultsSuccess != 0) {
    return getInteriorResultsSuccess;
  }

  initializeTime += initializeTimer.getTime();

  printOutput(boundingSphere,
	      resultsInterior,
	      resultsZeno,
	      parameters,
	      initializeTime,
	      readTime,
	      broadcastTime,
	      preprocessTime,
	      walkTime,
	      reduceTime,
	      surfacePreprocessTime,
	      sampleTime,
	      volumeReduceTime);

  savePointFiles(*resultsInterior,
		 *resultsZeno,
		 parameters);

  if ( resultsZeno ) {
     us_qdebug( "zeno delete resultsZeno" );
     delete resultsZeno;
  }
  if ( resultsInterior ) {
     us_qdebug( "zeno delete resultsInterior" );
     delete resultsInterior;
  }
  if ( spheresNearestSurfacePointFinder ) {
     us_qdebug( "zeno delete sphereNearestSurfacePointFinder" );
     delete spheresNearestSurfacePointFinder;
  }
  if ( spheresInsideOutsideTester ) {
     us_qdebug( "zeno delete spheresInsideOutsideTester" );
     delete spheresInsideOutsideTester;
  }

#ifdef USE_MPI
  MPI_Finalize();
#endif

  totalTimer.stop();

  if (mpiRank == 0) {
    zeno_cxx_fout->ofs << std::fixed
	      << "Total Time (s): " << totalTimer.getTime() << std::endl
	      << std::endl;

    printTime("End time: ");
  }

  return 0;
}

/// Get all input to the program, including both parameters and data, from the
/// command line and input files.
///
int
getInput(int argc, char **argv,
	 Parameters * parameters,
	 long long * numWalksInProcess,
	 long long * numSamplesInProcess,
	 Spheres<double> * spheres,
	 bool * spheresLoaded,
	 double * initializeTime,
	 double * readTime,
	 double * broadcastTime) {

  Timer initializeTimer;
  initializeTimer.start();

  parameters->parseCommandLine(argc, argv);

  if (parameters->getTotalNumWalksWasSet() &&
      (parameters->getMaxErrorCapacitanceWasSet() ||
       parameters->getMaxErrorPolarizabilityWasSet())) {

    zeno_cxx_fout->ofs << "Error: Cannot specify both number of walks and capacitance "
	      << "or polarizability tensor error" << std::endl;

    return 1;
  }

  if (parameters->getTotalNumSamplesWasSet() &&
      parameters->getMaxErrorVolumeWasSet()) {

    zeno_cxx_fout->ofs << "Error: Cannot specify both number of interior samples and "
	      << "volume error" << std::endl;

    return 1;
  }

  if (parameters->getComputeFormWasSet() &&
      !(parameters->getTotalNumSamplesWasSet() |
	parameters->getMaxErrorVolumeWasSet())) {

    zeno_cxx_fout->ofs << "Error: Must specify number of interior samples or volume "
	      << "error if computing form factors" << std::endl;

    return 1;
  }

  *numWalksInProcess = 
    computeNumInProcess(parameters->getMpiSize(), 
			parameters->getMpiRank(), 
			parameters->getTotalNumWalks());

  *numSamplesInProcess = 
    computeNumInProcess(parameters->getMpiSize(), 
			parameters->getMpiRank(), 
			parameters->getTotalNumSamples());

  if (parameters->getPrintBenchmarks() && 
      parameters->getMpiRank() == 0) {

    printRAM("RAM after initialization: ");
  }

  initializeTimer.stop();

  getBodData(parameters,
	     spheres,
	     readTime,
	     broadcastTime);

  initializeTimer.start();

  if (parameters->getPrintBenchmarks() && 
      parameters->getMpiRank() == 0) {

    printRAM("RAM after loading input data: ");
  }

  *spheresLoaded = !spheres->isEmpty();

  initializeTimer.stop();
  *initializeTime += initializeTimer.getTime();

  return 0;
}

/// Build the data structure used for the Walk-on-Spheres algorithm from either
/// voxel or sphere data.
///
int
preprocessWalkOnSpheres(bool spheresLoaded,
			Parameters const & parameters,
			Spheres<double> const & spheres,
			Sphere<double> * boundingSphere,
			SpheresModel * spheresModel,
			SpheresNearestSurfacePointFinder * *
			spheresNearestSurfacePointFinder,
			double * preprocessTime) {

  Timer preprocessTimer;
  preprocessTimer.start();

  if (spheresLoaded) {
    *boundingSphere = BoundingSphereGenerator::generate(spheres.getVector());

    spheresModel->preprocess(spheres.getVector(), 
			     parameters.getFracErrorBound());

    *spheresNearestSurfacePointFinder = 
      new SpheresNearestSurfacePointFinder(*spheresModel);
  }
  else {
    zeno_cxx_fout->ofs << "Warning: no spheres loaded" << std::endl;
  }

  if (parameters.getPrintBenchmarks() && 
      parameters.getMpiRank() == 0) {

    printRAM("RAM after building spatial data structure: ");
  }

  preprocessTimer.stop();
  *preprocessTime = preprocessTimer.getTime();

  return 0;
}

/// Allocate a random number generator for each thread, ensuring that each has
/// a unique stream ID across MPI processes.
///
void setupRNGs(Parameters const & parameters,
	       std::vector<RandomNumberGenerator> * threadRNGs) {

  int numStreams = 
    parameters.getNumThreads() * 
    parameters.getMpiSize();

  threadRNGs->reserve(parameters.getNumThreads());

  for (int threadNum = 0; threadNum < parameters.getNumThreads(); threadNum++) {
    int streamNum = 
      parameters.getMpiRank() * 
      parameters.getNumThreads() + 
      threadNum;

    threadRNGs->emplace_back(streamNum, numStreams, parameters.getSeed());
  }
}

/// Perform Walk-on-Spheres walks until the stopping condition is achieved
/// (either number of walks or error) and perform a parallel reduction on
/// the results.
///
int
getWalkOnSpheresResults(long long numWalksInProcess,			
			Parameters const & parameters,
			Sphere<double> const & boundingSphere,
			SpheresNearestSurfacePointFinder const * 
			spheresNearestSurfacePointFinder,			
			std::vector<RandomNumberGenerator> * threadRNGs,
			ResultsZeno * * resultsZeno,
			double * walkTime,
			double * reduceTime) {

  Timer reduceTimer;

  bool saveHitPoints = !parameters.getSurfacePointsFileName().empty();

  if (parameters.getTotalNumWalksWasSet()) {

    *resultsZeno = new ResultsZeno(boundingSphere,
				   parameters.getNumThreads(),
				   saveHitPoints);

    doWalkOnSpheresSelector(parameters,
			    numWalksInProcess,
			    boundingSphere, 
			    spheresNearestSurfacePointFinder,
			    threadRNGs,
			    *resultsZeno,
			    walkTime);

    reduceTimer.start();
    (*resultsZeno)->reduce();
    reduceTimer.stop();
  }
  else if (parameters.getMaxErrorCapacitanceWasSet() ||
	   parameters.getMaxErrorPolarizabilityWasSet()) {

    *resultsZeno = new ResultsZeno(boundingSphere,
				   parameters.getNumThreads(),
				   saveHitPoints);

    ResultsCompiler resultsCompiler(parameters);

    long long estimatedNumWalksRemaining = parameters.getMinTotalNumWalks();

    while (estimatedNumWalksRemaining > 0 && !*zeno_stop_flag) {

      long long estimatedNumWalksRemainingInProcess = 
	computeNumInProcess(parameters.getMpiSize(), 
			    parameters.getMpiRank(), 
			    estimatedNumWalksRemaining);

      doWalkOnSpheresSelector(parameters,
			      estimatedNumWalksRemainingInProcess,
			      boundingSphere, 
			      spheresNearestSurfacePointFinder,
			      threadRNGs,
			      *resultsZeno,
			      walkTime);

      reduceTimer.start();
      (*resultsZeno)->reduce();
      reduceTimer.stop();

      resultsCompiler.compile(*resultsZeno,
			      NULL,
			      boundingSphere,
			      false);

      long long estimatedTotalNumWalks = 0;

      long long capacitanceEstimatedTotalNumWalks = 
  	estimateTotalNum(parameters.getMaxErrorCapacitance(),
  			 (*resultsZeno)->getNumWalks(),
  			 resultsCompiler.getCapacitance());

      estimatedTotalNumWalks = std::max(estimatedTotalNumWalks,
  					capacitanceEstimatedTotalNumWalks);

      long long polarizabilityEstimatedTotalNumWalks = 
  	estimateTotalNum(parameters.getMaxErrorPolarizability(),
  			 (*resultsZeno)->getNumWalks(),
  			 resultsCompiler.getMeanPolarizability());

      estimatedTotalNumWalks = std::max(estimatedTotalNumWalks,
  					polarizabilityEstimatedTotalNumWalks);

      estimatedNumWalksRemaining = 
	estimatedTotalNumWalks - (*resultsZeno)->getNumWalks();

      if (estimatedNumWalksRemaining > 0) {
	estimatedNumWalksRemaining = 
	  std::max(estimatedNumWalksRemaining,
		   parameters.getMinTotalNumWalks());
      }
    }
  }

  if (parameters.getPrintBenchmarks() && 
      parameters.getMpiRank() == 0) {

    printRAM("RAM after walk on spheres: ");
  }

  *reduceTime = reduceTimer.getTime();

  return 0;
}

/// Build the data structure used for the Interior Sampling algorithm from 
/// either voxel or sphere data.
///
int
preprocessInterior(bool spheresLoaded,
		   Parameters const & parameters,
		   SpheresModel const & spheresModel,
		   SpheresInsideOutsideTester * *
		   spheresInsideOutsideTester,
		   double * surfacePreprocessTime) {

  Timer surfacePreprocessTimer;
  surfacePreprocessTimer.start();

  if (spheresLoaded) {
    *spheresInsideOutsideTester = new SpheresInsideOutsideTester(spheresModel);
  }

  surfacePreprocessTimer.stop();
  *surfacePreprocessTime = surfacePreprocessTimer.getTime();

  return 0;
}

/// Perform Interior samples until the stopping condition is achieved
/// (either number of walks or error) and perform a parallel reduction on
/// the results.
///
int
getInteriorResults(long long numSamplesInProcess,			
		   Parameters const & parameters,
		   Sphere<double> const & boundingSphere,
		   SpheresInsideOutsideTester const * 
		   spheresInsideOutsideTester,			
		   std::vector<RandomNumberGenerator> * threadRNGs,
		   ResultsInterior * * resultsInterior,
		   double * sampleTime,
		   double * volumeReduceTime) {

  bool saveInteriorPoints = 
    !parameters.getInteriorPointsFileName().empty() ||
    parameters.getComputeFormWasSet();

  Timer volumeReduceTimer;

  if (parameters.getTotalNumSamplesWasSet()) {

    *resultsInterior = new ResultsInterior(parameters.getNumThreads(),
					   saveInteriorPoints);

    doInteriorSamplingSelector(parameters,
			       numSamplesInProcess,
			       boundingSphere,
			       spheresInsideOutsideTester,
			       threadRNGs,
			       *resultsInterior,
			       sampleTime);

    volumeReduceTimer.start();
    (*resultsInterior)->reduce();
    volumeReduceTimer.stop();
  }
  else if (parameters.getMaxErrorVolumeWasSet()) {

    *resultsInterior = new ResultsInterior(parameters.getNumThreads(),
					   saveInteriorPoints);

    ResultsCompiler resultsCompiler(parameters);

    long long estimatedNumSamplesRemaining = parameters.getMinTotalNumSamples();

    while (estimatedNumSamplesRemaining > 0) {

      long long estimatedNumSamplesRemainingInProcess = 
	computeNumInProcess(parameters.getMpiSize(), 
			    parameters.getMpiRank(), 
			    estimatedNumSamplesRemaining);

      doInteriorSamplingSelector(parameters,
				 estimatedNumSamplesRemainingInProcess,
				 boundingSphere, 
				 spheresInsideOutsideTester,
				 threadRNGs,
				 *resultsInterior,
				 sampleTime);

      volumeReduceTimer.start();
      (*resultsInterior)->reduce();
      volumeReduceTimer.stop();

      resultsCompiler.compile(NULL,
			      *resultsInterior,
			      boundingSphere,
			      false);

      long long estimatedTotalNumSamples = 
	estimateTotalNum(parameters.getMaxErrorVolume(),
			 (*resultsInterior)->getNumSamples(),
			 resultsCompiler.getVolume());

      estimatedNumSamplesRemaining = 
	estimatedTotalNumSamples - (*resultsInterior)->getNumSamples();

      if (estimatedNumSamplesRemaining > 0) {
	estimatedNumSamplesRemaining = 
	  std::max(estimatedNumSamplesRemaining,
		   parameters.getMinTotalNumSamples());
      }
    }
  }

  if (parameters.getComputeFormWasSet()) {
    volumeReduceTimer.start();
    (*resultsInterior)->gatherHitPoints();
    volumeReduceTimer.stop();
  }

  if (parameters.getPrintBenchmarks() && 
      parameters.getMpiRank() == 0) {

    printRAM("RAM after interior samples: ");
  }

  *volumeReduceTime = volumeReduceTimer.getTime();

  return 0;
}

/// Divides a total number of samples as evenly as possible between a set of
/// MPI processes of a certain size, and returns how many samples the MPI
/// process of the given rank is responsible for.
/// 
long long 
computeNumInProcess(int mpiSize, int mpiRank,
		    long long totalNumSamples) {

  long long numSamplesInProcess = totalNumSamples / mpiSize;

  if (mpiRank < totalNumSamples % mpiSize) {
    numSamplesInProcess ++;
  }

  return numSamplesInProcess;
}

/// Parses the bod file given as input and extracts sphere data, voxel data,
/// and parameters.
///
void
parseBodFile(Parameters * parameters, 
	     Spheres<double> * spheres) {

  std::string fileName = parameters->getInputFileName();

  std::ifstream inputFile;

  inputFile.open(fileName, std::ifstream::in);

  if (!inputFile.is_open()) {
    zeno_cxx_fout->ofs << "Error opening input file " << fileName << std::endl;
    exit(1);
  }

  Parser parser(inputFile, parameters, spheres);

  parser.parse();

  inputFile.close();
}

/// Gets the data from the bod file given as input either by parsing the file
/// or by an MPI brodcast, depending on the MPI rank of the process.
///
void
getBodData(Parameters * parameters,
	   Spheres<double> * spheres,
	   double * readTime,
	   double * broadcastTime) {

  Timer readTimer;
  Timer broadcastTimer;

  if (parameters->getMpiRank() == 0) {
    readTimer.start();
    parseBodFile(parameters, spheres);
    readTimer.stop();

    broadcastTimer.start();
    spheres->mpiSend();
    parameters->mpiSend();
    broadcastTimer.stop();
  }
  else {
    broadcastTimer.start();
    spheres->mpiReceive();
    parameters->mpiReceive();
    broadcastTimer.stop();
  }

  *readTime      = readTimer.getTime();
  *broadcastTime = broadcastTimer.getTime();
}

/// Sets the default values for parameters that have them if the parameters
/// have not already been set.
///
void
computeDefaultParameters(Parameters * parameters,
			 Sphere<double> * boundingSphere) {

  const double defaultSkinThicknessFactor = 0.000001;

  if (parameters->getLaunchCenterWasSet()) {
    boundingSphere->setCenter(parameters->getLaunchCenter());
  }
  else {
    parameters->setLaunchCenter(boundingSphere->getCenter());
  }

  if (parameters->getLaunchRadiusWasSet()) {
    boundingSphere->setRadius(parameters->getLaunchRadius());
  }
  else {
    parameters->setLaunchRadius(boundingSphere->getRadius());
  }

  if (!parameters->getSkinThicknessWasSet()) {
    parameters->setSkinThickness(boundingSphere->getRadius() * 
				 defaultSkinThicknessFactor);
  }

  if (!parameters->getLengthScaleWasSet()) {
    parameters->setLengthScale(1, Units::Length::L);
  }
}

/// Estimates the total number of samples that will be required to acheive the
/// requested error, given the number of samples taken so far and the current
/// value and error.
///
long long 
estimateTotalNum(double requestedError,
		 long long numSoFar,
		 Uncertain<double> const & currentValue) {

  double requestedVariance = 
    pow((requestedError / 100) * currentValue.getMean(), 2);

  long long estimatedTotalNum = 
    ceil(currentValue.getVariance() * numSoFar / requestedVariance);

  return estimatedTotalNum;
}

/// Makes a call to the doWalkOnSpheres function with either sphere or voxel
/// data, depending which is not NULL.
///
void 
doWalkOnSpheresSelector(Parameters const & parameters,
			long long numWalksInProcess,
			Sphere<double> const & boundingSphere, 
			SpheresNearestSurfacePointFinder const * 
			spheresNearestSurfacePointFinder,
			std::vector<RandomNumberGenerator> * threadRNGs,
			ResultsZeno * resultsZeno,
			double * walkTime) {

  if (spheresNearestSurfacePointFinder != NULL) {
    doWalkOnSpheres(parameters.getNumThreads(),
		    numWalksInProcess,
		    boundingSphere, 
		    *spheresNearestSurfacePointFinder,
		    parameters.getFracErrorBound(),
		    parameters.getSkinThickness(),
		    threadRNGs,
		    resultsZeno,
		    walkTime);
  }
  else {
    assert(0);
  }
}

/// Launches a set of Walk-on-Spheres walks in each of a set of parallel 
/// threads.
///
template <class NearestSurfacePointFinder>
void
doWalkOnSpheres(int numThreads,
		long long numWalksInProcess,
		Sphere<double> const & boundingSphere, 
		NearestSurfacePointFinder const & 
		nearestSurfacePointFinder,
		double fracErrorBound,
		double shellThickness,
		std::vector<RandomNumberGenerator> * threadRNGs,
		ResultsZeno * resultsZeno,
		double * walkTime) {

  Timer walkTimer;
  walkTimer.start();

  std::thread * * threads = new std::thread *[numThreads];

  
  p0 = new std::promise < bool >;

  auto future = p0->get_future();

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {

    long long numWalksInThread = numWalksInProcess / numThreads;

    if (threadNum < numWalksInProcess % numThreads) {
      numWalksInThread ++;
    }

    threads[threadNum] = 
      new std::thread(doWalkOnSpheresThread<NearestSurfacePointFinder>,
		      boundingSphere, 
		      nearestSurfacePointFinder,
		      threadNum,
		      fracErrorBound,
		      shellThickness,
		      numWalksInThread,
		      &(threadRNGs->at(threadNum)),
		      resultsZeno);
  }

  {
     bool join_now = false;
     do {
        //us_qdebug("Inside_doWalkonSpheres21");
        auto status = future.wait_for(std::chrono::milliseconds(200));
        //us_qdebug("Inside_doWalkonSpheres22");

	if(!static_is_cmdline)
        {
           qApp->processEvents();
        }
	
	//us_qdebug("Inside_doWalkonSpheres23");
        if (status == std::future_status::ready) {
           join_now = true;
        }
     } while (!join_now );
  } 

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    threads[threadNum]->join();
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    delete threads[threadNum];
  }

  delete [] threads;

  delete p0;
  walkTimer.stop();
  *walkTime += walkTimer.getTime();
}

/// Launches a given number of Walk-on-Spheres walks and records the results.
/// Runs in a single thread.
///
template <class NearestSurfacePointFinder>
void
doWalkOnSpheresThread(Sphere<double> const & boundingSphere, 
		      NearestSurfacePointFinder const & 
		      nearestSurfacePointFinder,
		      int threadNum,
		      double fracErrorBound,
		      double shellThickness,
		      long long numWalks,
		      RandomNumberGenerator * randomNumberGenerator,
		      ResultsZeno * resultsZeno) {

  WalkerExterior<double, 
		 RandomNumberGenerator,
		 NearestSurfacePointFinder,
		 RandomSpherePointGenerator,
		 BiasedSpherePointGenerator>
    walker(randomNumberGenerator, 
	   boundingSphere, 
           nearestSurfacePointFinder,
           fracErrorBound,
	   shellThickness);

  for (long long walkNum = 0; walkNum < numWalks; walkNum++) {

    if(!static_is_cmdline)
    {
       if ( *zeno_stop_flag ){
          us_qdebug( "zeno stopped" );
          break;
       }
    }
    //us_qdebug(QString("Walk number_2: %1").arg(walkNum));
	
    if ( !threadNum && !( walkNum % 1000 ) ) {
       if (!static_is_cmdline){
#ifndef CMDLINE
          zeno_us_hydrodyn->do_update_progress( walkNum, numWalks );
#endif
       } else {
          if ( static_zeno_us_udp_msg ) {
             map < QString, QString > msging;
             msging[ "progress_output" ] = QString("Hydro (Zeno) calculation: %1\%").arg(QString::number( int((double(walkNum)/double(numWalks))*100.0) ) ).arg(100); // arg(ppos).arg(mppos);
             msging[ "progress1" ] = QString::number(double(walkNum)/double(numWalks));
		
             static_zeno_us_udp_msg->send_json( msging );
             //sleep(1);
          }   
	    
       }
    }
    //us_qdebug(QString("Walk number_3: %1").arg(walkNum));

    bool hitObject = false;
    int numSteps   = 0;

    Vector3<double> startPoint;
    Vector3<double> endPoint;
    Vector3<double> normal;

    walker.walk(&hitObject, &numSteps,
		&startPoint, &endPoint, &normal);

    if (hitObject) {
      resultsZeno->recordHit(threadNum, 
			     startPoint, endPoint, normal,
			     randomNumberGenerator);
    }
    else {
      resultsZeno->recordMiss(threadNum);
    }
  }

  if ( !threadNum ) {
     p0->set_value( true );
  }
}

/// Makes a call to the doInteriorSampling function with either sphere or voxel
/// data, depending which is not NULL.
///
void
doInteriorSamplingSelector(Parameters const & parameters,
			   long long numSamplesInProcess,
			   Sphere<double> const & boundingSphere,
			   SpheresInsideOutsideTester const *  
			   spheresInsideOutsideTester,
			   std::vector<RandomNumberGenerator> * threadRNGs,
			   ResultsInterior * resultsInterior,
			   double * sampleTime) {

  if (spheresInsideOutsideTester != NULL) {
    doInteriorSampling(parameters.getNumThreads(),
		       numSamplesInProcess,
		       boundingSphere, 
		       *spheresInsideOutsideTester,
		       parameters.getFracErrorBound(),
		       threadRNGs,
		       resultsInterior,
		       sampleTime);
  }
  else {
    assert(0);
  }
}

/// Launches a set of Interior samples in each of a set of parallel 
/// threads.
///
template <class InsideOutsideTester>
void
doInteriorSampling(int numThreads,
		   long long numSamplesInProcess,
		   Sphere<double> const & boundingSphere, 
		   InsideOutsideTester const & insideOutsideTester,
		   double fracErrorBound,
		   std::vector<RandomNumberGenerator> * threadRNGs,
		   ResultsInterior * resultsInterior,
		   double * sampleTime) {

  Timer sampleTimer;
  sampleTimer.start();

  std::thread * * threads = new std::thread *[numThreads];

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {

    long long numSamplesInThread = numSamplesInProcess / numThreads;

    if (threadNum < numSamplesInProcess % numThreads) {
      numSamplesInThread ++;
    }

    threads[threadNum] = 
      new std::thread(doInteriorSamplingThread<InsideOutsideTester>,
		      boundingSphere, 
		      insideOutsideTester,
		      threadNum,
		      fracErrorBound,
		      numSamplesInThread,
		      &(threadRNGs->at(threadNum)),
		      resultsInterior);
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    threads[threadNum]->join();
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    delete threads[threadNum];
  }

  delete [] threads;

  sampleTimer.stop();
  *sampleTime += sampleTimer.getTime();
}

/// Performs a given number of Interior samples and records the results.
/// Runs in a single thread.
///
template <class InsideOutsideTester>
void
doInteriorSamplingThread(Sphere<double> const & boundingSphere, 
			 InsideOutsideTester const & insideOutsideTester,
			 int threadNum,
			 double fracErrorBound,
			 long long numSamples,
			 RandomNumberGenerator * randomNumberGenerator,
			 ResultsInterior * resultsInterior) {

  SamplerInterior<double, 
		 RandomNumberGenerator,
		 InsideOutsideTester,
		 RandomBallPointGenerator>
    sampler(randomNumberGenerator, 
	    boundingSphere, 
	    insideOutsideTester,
	    fracErrorBound);

  for (long long sampleNum = 0; sampleNum < numSamples; sampleNum++) {

    bool hitObject = false;

    Vector3<double> hitPoint;

    sampler.sample(&hitObject,
		   &hitPoint);

    if (hitObject) {
      resultsInterior->recordHit(threadNum,
				 hitPoint);
    }
    else {
      resultsInterior->recordMiss(threadNum);
    }
  }
}

/// Prints parameters, results, and (optionally) detailed running time
/// benchmarks on MPI process 0.
///
void
printOutput(Sphere<double> const & boundingSphere,
	    ResultsInterior const * resultsInterior,
	    ResultsZeno const * resultsZeno,
	    Parameters const & parameters, 
	    double initializeTime,
	    double readTime,
	    double broadcastTime,
	    double preprocessTime,
	    double walkTime,
	    double reduceTime,
	    double surfacePreprocessTime,
	    double sampleTime,
	    double volumeReduceTime) {

  if (parameters.getMpiRank() == 0) {
    zeno_cxx_fout->ofs << std::endl
	      << "Parameters" << std::endl
	      << "----------" << std::endl
	      << std::endl;

    parameters.print();

    zeno_cxx_fout->ofs << std::endl
	      << "Results" << std::endl
	      << "-------" << std::endl
	      << std::endl;

    if (resultsZeno != NULL) {

      zeno_cxx_fout->ofs << "Number of walks performed: " 
		<< (long long)resultsZeno->getNumWalks() << std::endl
		<< std::endl;
    }

    if (resultsInterior != NULL) {

      zeno_cxx_fout->ofs << "Number of interior samples taken: " 
		<< (long long)resultsInterior->getNumSamples() << std::endl
		<< std::endl;
    }

    ResultsCompiler resultsCompiler(parameters);

    resultsCompiler.compile(resultsZeno,
			    resultsInterior,
			    boundingSphere,
			    parameters.getComputeFormWasSet());

    resultsCompiler.print(parameters.getPrintCounts());

    if (parameters.getPrintBenchmarks()) {
      zeno_cxx_fout->ofs << std::fixed
		<< "Initialize (s):         " << initializeTime << std::endl
		<< "Read (s):               " << readTime << std::endl
		<< "Broadcast (s):          " << broadcastTime << std::endl
		<< "Centers Preprocess (s): " << preprocessTime << std::endl
		<< "Exterior Walk (s):      " << walkTime << std::endl
		<< "Exterior Reduce (s):    " << reduceTime << std::endl
		<< "Surface Preprocess (s): " << surfacePreprocessTime 
		<< std::endl
		<< "Volume Sample (s):      " << sampleTime << std::endl
		<< "Volume Reduce (s):      " << volumeReduceTime << std::endl
		<< std::endl;
    }
  }
}

/// Writes Walk-on-Spheres and Interior Sampling hit points to disk.
/// 
void
savePointFiles(ResultsInterior & resultsInterior,
	       ResultsZeno & resultsZeno,
	       Parameters const & parameters) {

  if (!parameters.getSurfacePointsFileName().empty()) {
    resultsZeno.gatherHitPoints();

    writePoints(parameters.getSurfacePointsFileName(), 
		resultsZeno.getPoints(), 
		resultsZeno.getCharges());
  }

  if (!parameters.getInteriorPointsFileName().empty()) {
    resultsInterior.gatherHitPoints();

    writePoints(parameters.getInteriorPointsFileName(), 
		resultsInterior.getPoints(), 
		NULL);
  }
}

/// Prints the current date and time prefixed by the given label.
///
void
printTime(std::string const & label) {
#if !defined( Q_OS_WIN )
  const int bufferSize = 256;

  time_t rawtime;
  struct tm * timeinfo;
  char buffer[bufferSize];
    
  time(&rawtime);
  timeinfo = localtime(&rawtime);
    
  strftime(buffer, bufferSize, "%F %T", timeinfo);
  
  zeno_cxx_fout->ofs << label << buffer << std::endl;
#endif
}

/// Prints the current RAM used by the process prefixed by the given label.
///
void
printRAM(std::string const & label) {
  std::ifstream statusFile("/proc/self/status");

  std::string line;

  while (statusFile.good()) {
    std::getline(statusFile, line);

    size_t pos = line.find("VmRSS:");

    if (pos != std::string::npos) {
      zeno_cxx_fout->ofs << label << line.substr(pos + 6) << std::endl;
    }
  }

  statusFile.close();
}

/// Writes the given set of points and (if not NULL) charges to disk.
///
void
writePoints(std::string const & fileName, 
	    std::vector<Vector3<double> > const * points,
	    std::vector<Vector3<char> > const * charges) {

  std::ofstream outputFile;

  outputFile.open(fileName, std::ofstream::out);

  if (!outputFile.is_open()) {

    zeno_cxx_fout->ofs << "Error opening output file " << fileName << std::endl;
    exit(1);
  }

  for (unsigned int i = 0; i < points->size(); i++) {

    if (charges != NULL) {
      outputFile << charges->at(i).get(0)
		 << charges->at(i).get(1)
		 << charges->at(i).get(2);
    }

    outputFile << std::setw(16) << points->at(i).get(0)
	       << std::setw(16) << points->at(i).get(1)
	       << std::setw(16) << points->at(i).get(2) << std::endl;
  }

  outputFile.close();
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Main.cc ***

// *** START *** Parser.cc ***
// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Mon Feb 24 11:24:59 2014 EDT
//
// Time-stamp: <2016-09-22 13:10:45 dcj>
//
// ================================================================

// inlined #include "Parser.h"

// inlined #include "Geometry/Vector3.h"
// inlined #include "Geometry/Sphere.h"

// ================================================================

Parser::Parser(std::istream &in,
	       Parameters * parameters,
	       Spheres<double> * spheres) :
  d_scanner(in),
  parameters(parameters),
  spheres(spheres){

}

void Parser::addSphere(double x, double y, double z, double r) {
  Vector3<double> center(x, y, z);

  Sphere<double> sphere(center, r);

  spheres->add(sphere);
}

void Parser::setST(double skinThickness) {
  parameters->setSkinThickness(skinThickness);
}

void Parser::setRLAUNCH(double launchRadius) {
  parameters->setLaunchRadius(launchRadius);
}

void Parser::setHUNITS(double number, std::string unitString) {
  Units::Length units;

  if (unitString == "m") {
    units = Units::Length::m;
  }
  else if (unitString == "cm") {
    units = Units::Length::cm;
  }
  else if (unitString == "nm") {
    units = Units::Length::nm;
  }
  else if (unitString == "A") {
    units = Units::Length::A;
  }
  else if (unitString == "L") {
    units = Units::Length::L;
  }
  else {
    std::cerr << "Error: invalid length unit " << unitString << std::endl;
    exit(1);
  }

  parameters->setLengthScale(number, units);
}

void Parser::setUNITS(std::string unitString) {
  setHUNITS(1, unitString);
}

void Parser::setTEMP(double number, std::string unitString) {
  Units::Temperature units;

  if (unitString == "C") {
    units = Units::Temperature::C;
  }
  else if (unitString == "K") {
    units = Units::Temperature::K;
  }
  else {
    std::cerr << "Error: invalid temperature unit " << unitString << std::endl;
    exit(1);
  }

  parameters->setTemperature(number, units);
}

void Parser::setMASS(double number, std::string unitString) {
  Units::Mass units;

  if (unitString == "Da") {
    units = Units::Mass::Da;
  }
  else if (unitString == "kDa") {
    units = Units::Mass::kDa;
  }
  else if (unitString == "g") {
    units = Units::Mass::g;
  }
  else if (unitString == "kg") {
    units = Units::Mass::kg;
  }
  else {
    std::cerr << "Error: invalid mass unit " << unitString << std::endl;
    exit(1);
  }

  parameters->setMass(number, units);
}

void Parser::setVISCOSITY(double number, std::string unitString) {
  Units::Viscosity units;

  if (unitString == "p") {
    units = Units::Viscosity::p;
  }
  else if (unitString == "cp") {
    units = Units::Viscosity::cp;
  }
  else {
    std::cerr << "Error: invalid viscosity unit " << unitString << std::endl;
    exit(1);
  }

  parameters->setSolventViscosity(number, units);
}

void Parser::setBF(double buoyancyFactor) {
  parameters->setBuoyancyFactor(buoyancyFactor);
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Parser.cc ***

// *** START *** Parameters.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Author:  Derek Juba <derek.juba@nist.gov>
// Date:    Tue Jan 05 16:39:56 2016 EDT
// 
// Time-stamp: <2016-09-28 16:15:33 dcj>
// 
// ================================================================

#ifdef USE_MPI
#include <mpi.h>
#endif

#include <thread>
#include <cassert>
#include <iostream>
#include <fstream>

// inlined #include "cmdline.h"

// inlined #include "Parameters.h"

// ================================================================

Parameters::Parameters() 
  : inputFileName(), 
    mpiSize(1),
    mpiRank(0),
    numThreads(),
    seed(),
    fracErrorBound(),
    totalNumWalks(),
    totalNumWalksWasSet(false),
    totalNumSamples(),
    totalNumSamplesWasSet(false),
    maxErrorCapacitance(),
    maxErrorCapacitanceWasSet(false),
    maxErrorPolarizability(),
    maxErrorPolarizabilityWasSet(false),
    maxErrorVolume(),
    maxErrorVolumeWasSet(false),
    computeFormWasSet(false),
    minTotalNumWalks(),
    minTotalNumSamples(),
    surfacePointsFileName(),
    interiorPointsFileName(),
    printCounts(),
    printBenchmarks(),
    skinThickness(),
    skinThicknessWasSet(false),
    launchCenter(),
    launchCenterWasSet(false),
    launchRadius(),
    launchRadiusWasSet(false),
    lengthScale(),
    lengthScaleUnit(),
    lengthScaleWasSet(false),
    temperature(),
    temperatureUnit(),
    temperatureWasSet(false),
    mass(),
    massUnit(),
    massWasSet(false),
    solventViscosity(),
    solventViscosityUnit(),
    solventViscosityWasSet(false),
    buoyancyFactor(),
    buoyancyFactorWasSet(false) {

}

Parameters::~Parameters() {

}

/// Parses the command line and stores the values of the parameters it
/// contains.
///
/// Also sets default values for numThreads and seed.
///
void 
Parameters::parseCommandLine(int argc, char **argv) {
  struct gengetopt_args_info args_info;
  struct cmdline_parser_params *params;

  params = cmdline_parser_params_create();

  params->initialize = 1;
  params->check_required = 1;

  if (cmdline_parser_ext(argc, argv, &args_info, params) != 0) {
    cmdline_parser_free(&args_info);
    free(params);
    exit(1);
  }

  inputFileName      = args_info.input_file_arg;
  minTotalNumWalks   = args_info.min_num_walks_arg;
  minTotalNumSamples = args_info.min_num_interior_samples_arg;
  fracErrorBound     = args_info.frac_error_bound_arg;

  if (args_info.num_walks_given) {
    totalNumWalks = args_info.num_walks_arg;
    totalNumWalksWasSet = true;
  }

  if (args_info.num_interior_samples_given) {
    totalNumSamples = args_info.num_interior_samples_arg;
    totalNumSamplesWasSet = true;
  }

  if (args_info.max_rsd_capacitance_given) {
    maxErrorCapacitance = args_info.max_rsd_capacitance_arg;
    maxErrorCapacitanceWasSet = true;
  }

  if (args_info.max_rsd_polarizability_given) {
    maxErrorPolarizability = args_info.max_rsd_polarizability_arg;
    maxErrorPolarizabilityWasSet = true;
  }

  if (args_info.max_rsd_volume_given) {
    maxErrorVolume = args_info.max_rsd_volume_arg;
    maxErrorVolumeWasSet = true;
  }

  // if (args_info.compute_form_given) {
  //   computeFormWasSet = true;
  // }

  if (args_info.num_threads_given) {
    numThreads = args_info.num_threads_arg;
  }
  else {
    numThreads = std::thread::hardware_concurrency();

    if (numThreads == 0) {
      numThreads = 1;
    }
  }

  if (args_info.seed_given) {
    seed = args_info.seed_arg;
  }
  else {
    std::ifstream urandom("/dev/urandom");

    urandom.read((char *)&seed, sizeof(seed));

    if (!urandom.good()) {
      zeno_cxx_fout->ofs << "Error randomly setting seed for random number generator"
		<< std::endl;
    }

    urandom.close();

    seed = abs(seed);
  }

  if (args_info.surface_points_file_given) {
    surfacePointsFileName = args_info.surface_points_file_arg;
  }
  else {
    surfacePointsFileName = "";
  }

  if (args_info.interior_points_file_given) {
    interiorPointsFileName = args_info.interior_points_file_arg;
  }
  else {
    interiorPointsFileName = "";
  }

  printCounts     = args_info.print_counts_given;
  printBenchmarks = args_info.print_benchmarks_given;

  free(params);
}

/// Prints the parameters.  Most parameters are not printed if they have not
/// been set.
/// 
void
Parameters::print() const {
  zeno_cxx_fout->ofs << "Input file: " <<  inputFileName << std::endl 
	    << "Number of nodes: " << mpiSize << std::endl
	    << "Number of threads: " << numThreads << std::endl
	    << "Random number seed: " << seed << std::endl;

  if (totalNumWalksWasSet) {
    zeno_cxx_fout->ofs << "Number of walks: " << totalNumWalks << std::endl;
  }

  if (totalNumSamplesWasSet) {
    zeno_cxx_fout->ofs << "Number of interior samples: " << totalNumSamples << std::endl;
  }

  if (maxErrorCapacitanceWasSet) {
    zeno_cxx_fout->ofs << "Max error in capacitance: " << maxErrorCapacitance << " %" 
	      << std::endl;
  }

  if (maxErrorPolarizabilityWasSet) {
    zeno_cxx_fout->ofs << "Max error in mean polarizability: " << maxErrorPolarizability
	      << " %" << std::endl;
  }

  if (maxErrorVolumeWasSet) {
    zeno_cxx_fout->ofs << "Max error in volume: " << maxErrorVolume << " %" << std::endl;
  }

  if (skinThicknessWasSet) {
    zeno_cxx_fout->ofs << "Skin thickness: " << skinThickness << std::endl;
  }

  if (launchCenterWasSet) {
    zeno_cxx_fout->ofs << "Launch center: " << launchCenter << std::endl;
  }

  if (launchRadiusWasSet) {
    zeno_cxx_fout->ofs << "Launch radius: " << launchRadius << std::endl;
  }

  if (lengthScaleWasSet) {
    zeno_cxx_fout->ofs << "Length scale: " << lengthScale << " "
	      << Units::getName(lengthScaleUnit) << std::endl;
  }

  if (temperatureWasSet) {
    zeno_cxx_fout->ofs << "Temperature: " << temperature << " "
	      << Units::getName(temperatureUnit) << std::endl;
  }

  if (massWasSet) {
    zeno_cxx_fout->ofs << "Mass: " << mass << " "
	      << Units::getName(massUnit) << std::endl;
  }

  if (solventViscosityWasSet) {
    zeno_cxx_fout->ofs << "Solvent viscosity: " << solventViscosity << " "
	      << Units::getName(solventViscosityUnit) << std::endl;
  }

  if (buoyancyFactorWasSet) {
    zeno_cxx_fout->ofs << "Buoyancy factor: " << buoyancyFactor << std::endl;
  }
}

std::string 
Parameters::getInputFileName() const { 
  return inputFileName;
}

int
Parameters::getMpiSize() const {
  return mpiSize;
}

void
Parameters::setMpiSize(int mpiSize) {
  this->mpiSize = mpiSize;
}

int
Parameters::getMpiRank() const {
  return mpiRank;
}

void
Parameters::setMpiRank(int mpiRank) {
  this->mpiRank = mpiRank;
}

int 
Parameters::getNumThreads() const {
  return numThreads;
}

int 
Parameters::getSeed() const {
  return seed;
}

double 
Parameters::getFracErrorBound() const {
  return fracErrorBound;
}

long long 
Parameters::getTotalNumWalks() const {
  return totalNumWalks;
}

bool
Parameters::getTotalNumWalksWasSet() const {
  return totalNumWalksWasSet;
}

long long 
Parameters::getTotalNumSamples() const {
  return totalNumSamples;
}

bool 
Parameters::getTotalNumSamplesWasSet() const {
  return totalNumSamplesWasSet;
}

double
Parameters::getMaxErrorCapacitance() const {
  return maxErrorCapacitance;
}

bool
Parameters::getMaxErrorCapacitanceWasSet() const {
  return maxErrorCapacitanceWasSet;
}

double
Parameters::getMaxErrorPolarizability() const {
  return maxErrorPolarizability;
}

bool
Parameters::getMaxErrorPolarizabilityWasSet() const {
  return maxErrorPolarizabilityWasSet;
}

bool
Parameters::getComputeFormWasSet() const {
  return computeFormWasSet;
}

double
Parameters::getMaxErrorVolume() const {
  return maxErrorVolume;
}

bool
Parameters::getMaxErrorVolumeWasSet() const {
  return maxErrorVolumeWasSet;
}

long long 
Parameters::getMinTotalNumWalks() const {
  return minTotalNumWalks;
}

long long 
Parameters::getMinTotalNumSamples() const {
  return minTotalNumSamples;
}

std::string 
Parameters::getSurfacePointsFileName() const {
  return surfacePointsFileName;
}

std::string 
Parameters::getInteriorPointsFileName() const {
  return interiorPointsFileName;
}

bool 
Parameters::getPrintCounts() const {
  return printCounts;
}

bool 
Parameters::getPrintBenchmarks() const {
  return printBenchmarks;
}

void 
Parameters::setSkinThickness(double skinThickness) {
  this->skinThickness = skinThickness;

  skinThicknessWasSet = true;
}

double
Parameters::getSkinThickness() const {
  return skinThickness;
}

bool
Parameters::getSkinThicknessWasSet() const {
  return skinThicknessWasSet;
}

void 
Parameters::setLaunchCenter(Vector3<double> launchCenter) {
  this->launchCenter = launchCenter;

  launchCenterWasSet = true;
}

Vector3<double>
Parameters::getLaunchCenter() const {
  return launchCenter;
}

bool 
Parameters::getLaunchCenterWasSet() const {
  return launchCenterWasSet;
}

void 
Parameters::setLaunchRadius(double launchRadius) {
  this->launchRadius = launchRadius;

  launchRadiusWasSet = true;
}

double
Parameters::getLaunchRadius() const {
  return launchRadius;
}

bool 
Parameters::getLaunchRadiusWasSet() const {
  return launchRadiusWasSet;
}

void
Parameters::setLengthScale(double number, Units::Length unit) {
  lengthScale     = number;
  lengthScaleUnit = unit;

  lengthScaleWasSet = true;
}

double
Parameters::getLengthScaleNumber() const {
  return lengthScale;
}

Units::Length
Parameters::getLengthScaleUnit() const {
  return lengthScaleUnit;
}

bool
Parameters::getLengthScaleWasSet() const {
  return lengthScaleWasSet;
}

void 
Parameters::setTemperature(double number, Units::Temperature unit) {
  temperature     = number;
  temperatureUnit = unit;

  temperatureWasSet = true;
}

double
Parameters::getTemperatureNumber() const {
  return temperature;
}

Units::Temperature
Parameters::getTemperatureUnit() const {
  return temperatureUnit;
}

bool
Parameters::getTemperatureWasSet() const {
  return temperatureWasSet;
}

void
Parameters::setMass(double number, Units::Mass unit) {
  mass     = number;
  massUnit = unit;

  massWasSet = true;
}

double 
Parameters::getMassNumber() const {
  return mass;
}

Units::Mass
Parameters::getMassUnit() const {
  return massUnit;
}

bool
Parameters::getMassWasSet() const {
  return massWasSet;
}

void 
Parameters::setSolventViscosity(double number, Units::Viscosity unit) {
  solventViscosity     = number;
  solventViscosityUnit = unit;

  solventViscosityWasSet = true;
}

double
Parameters::getSolventViscosityNumber() const {
  return solventViscosity;
}

Units::Viscosity
Parameters::getSolventViscosityUnit() const {
  return solventViscosityUnit;
}

bool
Parameters::getSolventViscosityWasSet() const {
  return solventViscosityWasSet;
}

void 
Parameters::setBuoyancyFactor(double buoyancyFactor) {
  this->buoyancyFactor = buoyancyFactor;

  buoyancyFactorWasSet = true;
}

double
Parameters::getBuoyancyFactor() const {
  return buoyancyFactor;
}

bool
Parameters::getBuoyancyFactorWasSet() const {
  return buoyancyFactorWasSet;
}

/// Broadcasts the parameters that can be set in the bod file over MPI.
///
void 
Parameters::mpiSend() const {
#ifdef USE_MPI
  double parametersArray[22];

  parametersArray[0]  = getSkinThickness();
  parametersArray[1]  = (double)getSkinThicknessWasSet();
  parametersArray[2]  = getLaunchCenter().getX();
  parametersArray[3]  = getLaunchCenter().getY();
  parametersArray[4]  = getLaunchCenter().getZ();
  parametersArray[5]  = (double)getLaunchCenterWasSet();
  parametersArray[6]  = getLaunchRadius();
  parametersArray[7]  = (double)getLaunchRadiusWasSet();
  parametersArray[8]  = getLengthScaleNumber();
  parametersArray[9]  = (double)getLengthScaleUnit();
  parametersArray[10] = (double)getLengthScaleWasSet();
  parametersArray[11] = getTemperatureNumber();
  parametersArray[12] = (double)getTemperatureUnit();
  parametersArray[13] = (double)getTemperatureWasSet();
  parametersArray[14] = getMassNumber();
  parametersArray[15] = (double)getMassUnit();
  parametersArray[16] = (double)getMassWasSet();
  parametersArray[17] = getSolventViscosityNumber();
  parametersArray[18] = (double)getSolventViscosityUnit();
  parametersArray[19] = (double)getSolventViscosityWasSet();
  parametersArray[20] = getBuoyancyFactor();
  parametersArray[21] = (double)getBuoyancyFactorWasSet();

  MPI_Bcast(parametersArray, 22, MPI_DOUBLE, 0, MPI_COMM_WORLD);
#endif
}

/// Receives the parameters that can be set in the bod file over MPI.
///
void 
Parameters::mpiReceive() {
#ifdef USE_MPI
  double parametersArray[22];

  MPI_Bcast(parametersArray, 22, MPI_DOUBLE, 0, MPI_COMM_WORLD);

  if ((bool)parametersArray[1]) {
    setSkinThickness(parametersArray[0]);
  }

  if ((bool)parametersArray[5]) {
    setLaunchCenter(Vector3<double>(parametersArray[2],
				    parametersArray[3],
				    parametersArray[4]));
  }

  if ((bool)parametersArray[7]) {
    setLaunchRadius(parametersArray[6]);
  }

  if ((bool)parametersArray[10]) {
    setLengthScale(parametersArray[8], 
		   (Units::Length)parametersArray[9]);
  }

  if ((bool)parametersArray[13]) {
    setTemperature(parametersArray[11],
		   (Units::Temperature)parametersArray[12]);
  }

  if ((bool)parametersArray[16]) {
    setMass(parametersArray[14],
	    (Units::Mass)parametersArray[15]);
  }

  if ((bool)parametersArray[19]) {
    setSolventViscosity(parametersArray[17],
			(Units::Viscosity)parametersArray[18]);
  }

  if ((bool)parametersArray[21]) {
    setBuoyancyFactor(parametersArray[20]);
  }
#endif
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Parameters.cc ***

// *** START *** Timer.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Author:  Derek Juba <derek.juba@nist.gov>
// Date:    Wed May 21 16:22:30 2014 EDT
// 
// Time-stamp: <2016-08-30 11:50:34 dcj>
// 
// ================================================================

// inlined #include "Timer.h"

#include <ctime>
#include <ratio>

// ================================================================

using namespace std::chrono;

// ================================================================

/// Construct a Timer with 0s on the clock.
///
Timer::Timer() 
  : running(false),
    startTime(),
    elapsedTime(0) {

}

Timer::~Timer() {

}

/// Start the Timer.  Any previous time on the Timer is not cleared.
///
void 
Timer::start() {
  if (!running) {
    running = true;

    startTime = high_resolution_clock::now();
  }
}

/// Stop the Timer.  The time on the Timer is not cleared.
///
void 
Timer::stop() {
  if (running) {
    running = false;

    high_resolution_clock::time_point endTime = high_resolution_clock::now();

    elapsedTime += 
      (duration_cast<duration<double>>(endTime - startTime)).count();
  }
}

/// Set the time on the Timer to 0s.  If the Timer is running, it is not
/// stopped.
///
void 
Timer::reset() {
  elapsedTime = 0;

  startTime = high_resolution_clock::now();
}


/// Returns the current time on the Timer.  Can be called even if the Timer is
/// running.
///
double
Timer::getTime() const {
  if (running) {
    high_resolution_clock::time_point endTime = high_resolution_clock::now();

    double currentTime = 
      (duration_cast<duration<double>>(endTime - startTime)).count();

    return currentTime + elapsedTime;
  }
  else {
    return elapsedTime;
  }
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Timer.cc ***

// *** START *** Units.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Author:  Derek Juba <derek.juba@nist.gov>
// Date:    Tue Jan 12 17:37:19 2016 EDT
// 
// Time-stamp: <2016-08-30 16:34:34 dcj>
// 
// ================================================================

#include <cassert>
#include <cmath>

// inlined #include "Units.h"

// ================================================================

Uncertain<double> 
Units::getFactor(Length fromUnit, Length toUnit) {
  assert(toUnit == Length::cm);

  switch(fromUnit) {
  case Length::m: 
    return 100; 
  case Length::cm:
    return 1;
  case Length::nm:
    return pow(10, -7);
  case Length::A:
    return pow(10, -8);
  default:
    assert(0);
  }
}
 
Uncertain<double> 
Units::getFactor(Mass fromUnit, Mass toUnit) {
  assert(toUnit == Mass::g);

  switch(fromUnit) {
  case Mass::Da:
    return Uncertain<double>(6.022140857*pow(10, 23), pow(10, 18 * 2));
  case Mass::kDa:
    return Uncertain<double>(6.022140857*pow(10, 20), pow(10, 15 * 2));
  case Mass::g:
    return 1;
  case Mass::kg:
    return pow(10, -3);
  default:
    assert(0);
  }
}

Uncertain<double> 
Units::getFactor(Viscosity fromUnit, Viscosity toUnit) {
  assert(toUnit == Viscosity::cp);

  switch(fromUnit) {
  case Viscosity::cp:
    return 1;
  case Viscosity::p:
    return 100;
  default:
    assert(0);
  }
}

Uncertain<double> 
Units::getOffset(Temperature fromUnit, Temperature toUnit) {
  assert(toUnit == Temperature::K);

  switch(fromUnit) {
  case Temperature::C:
    return 273.15;
  case Temperature::K:
    return 0;
  default:
    assert(0);
  }
}

std::string 
Units::getName(Length unit) {
  switch(unit) {
  case Length::m:
    return "m";
  case Length::cm:
    return "cm";
  case Length::nm:
    return "nm";
  case Length::A:
    return "A";
  case Length::L:
    return "L";
  default:
    assert(0);
  }
}

std::string 
Units::getName(Temperature unit) {
  switch(unit) {
  case Temperature::C:
    return "C";
  case Temperature::K:
    return "K";
  default:
    assert(0);
  }
}

std::string 
Units::getName(Mass unit) {
  switch(unit) {
  case Mass::Da:
    return "Da";
  case Mass::kDa:
    return "kDa";
  case Mass::g:
    return "g";
  case Mass::kg:
    return "kg";
  default:
    assert(0);
  }
}

std::string 
Units::getName(Viscosity unit) {
  switch(unit) {
  case Viscosity::p:
    return "p";
  case Viscosity::cp:
    return "cp";
  default:
    assert(0);
  } 
}

/// Returns Boltzmann's constant.
///
Uncertain<double> 
Units::kB() {
  return Uncertain<double>(1.38064852*pow(10, -23), pow(10, -28 * 2));
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** Units.cc ***

// *** START *** ResultsCompiler.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Wed Apr 22 11:11:48 2015 EDT
//
// Time-stamp: <2016-09-28 12:07:33 dcj>
//
// ================================================================

#ifdef USE_MPI
#include <mpi.h>
#endif

#include <cassert>
#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <thread>

// inlined #include "ResultsCompiler.h"

// ================================================================

ResultsCompiler::
ResultsCompiler(Parameters const & parameters) 
  : parameters(&parameters),
    boundingSphereRadius(),
    boundingSphereCenter(),
    t(),
    u(),
    v(),
    w(),
    capacitance(),
    polarizabilityTensor(),
    meanPolarizability(),
    polarizabilityEigenvalues(),
    volume(),
    intrinsicConductivity(),
    capacitanceOfASphere(),
    hydrodynamicRadius(),
    q_eta(),
    viscometricRadius(),
    intrinsicViscosity(),
    intrinsicViscosityConventional(),
    frictionCoefficient(),
    diffusionCoefficient(),
    sedimentationCoefficient(),
    gyrationTensor(),
    gyrationEigenvalues(),
    formFactors(),
    intrinsicViscosityConventionalComputed(false),
    frictionCoefficientComputed(false),
    diffusionCoefficientComputed(false),
    sedimentationCoefficientComputed(false),
    resultsZenoCompiled(false), 
    resultsInteriorCompiled(false),
    formResultsCompiled(false) {

}

ResultsCompiler::
~ResultsCompiler() {

}

/// Derives physical quantities from the Walk-on-Spheres and Interior Sampling
/// results.  Either of the results may be NULL, in which case only some of the
/// physical quantities will be computed.  Computation of Form Factors is 
/// optional, due to speed.
///
void 
ResultsCompiler::compile(ResultsZeno const * resultsZeno,
			 ResultsInterior const * resultsInterior,
			 Sphere<double> const & boundingSphere,
			 bool computeForm) {

  boundingSphereRadius = boundingSphere.getRadius();
  boundingSphereCenter = boundingSphere.getCenter();

  if ((resultsZeno != NULL) &&
      (resultsZeno->getNumHits() == 0.)) {

    std::cerr << "*** Warning ***" << std::endl
	      << "Number of walker hits is zero.  "
	      << "Corresponding results will not be computed.  "
	      << "Try increasing the number of walks?" << std::endl
	      << std::endl;

    resultsZeno = NULL;
  }

  if ((resultsInterior != NULL) &&
      (resultsInterior->getNumHits() == 0.)) {

    std::cerr << "*** Warning ***" << std::endl
	      << "Number of interior sampler hits is zero.  "
	      << "Corresponding results will not be computed.  "
	      << "Try increasing the number of interior samples?" << std::endl
	      << std::endl;

    resultsInterior = NULL;
  }

  if (resultsZeno != NULL) {

    double numWalks = resultsZeno->getNumWalks();

    Uncertain<double> numZenoHits = resultsZeno->getNumHits();

    Vector3<Uncertain<double> > KPlus  = resultsZeno->getKPlus();
    Vector3<Uncertain<double> > KMinus = resultsZeno->getKMinus();

    Matrix3x3<Uncertain<double> > VPlus  = resultsZeno->getVPlus();
    Matrix3x3<Uncertain<double> > VMinus = resultsZeno->getVMinus();

    t = numZenoHits/numWalks;
    u = (KPlus - KMinus)/numWalks;
    v = (VPlus + VMinus)/numWalks;
    w = (VPlus - VMinus)/numWalks;

    capacitance = computeCapacitance(t, boundingSphereRadius);

    polarizabilityTensor = computePolarizability(t, u, v, w, 
						 boundingSphereRadius);

    meanPolarizability = computeMeanPolarizability(polarizabilityTensor);

    polarizabilityTensor.getEigenValues(polarizabilityEigenvalues);

    hydrodynamicRadius = computeHydrodynamicRadius(capacitance);

    q_eta = computePadeApproximant(polarizabilityTensor);

    viscometricRadius = computeViscometricRadius(meanPolarizability,
						 q_eta);

    if (parameters->getMassWasSet()) {

      intrinsicViscosityConventional = 
	computeIntrinsicViscosityConventional(q_eta,
					      meanPolarizability,
					      parameters->getMassNumber());

      intrinsicViscosityConventionalComputed = true;
    }

    if ((parameters->getLengthScaleUnit() != Units::Length::L) &&
	parameters->getSolventViscosityWasSet()) {

      frictionCoefficient = 
	computeFrictionCoefficient(parameters->getSolventViscosityNumber(),
				   hydrodynamicRadius);

      frictionCoefficientComputed = true;
    }

    if ((parameters->getLengthScaleUnit() != Units::Length::L) &&
	parameters->getSolventViscosityWasSet() &&
	parameters->getTemperatureWasSet()) {

      diffusionCoefficient = 
	computeDiffusionCoefficient(parameters->getTemperatureNumber(),
				    parameters->getSolventViscosityNumber(),
				    hydrodynamicRadius);

      diffusionCoefficientComputed = true;
    }

    if ((parameters->getLengthScaleUnit() != Units::Length::L) &&
	parameters->getSolventViscosityWasSet() &&
	parameters->getBuoyancyFactorWasSet() &&
	parameters->getMassWasSet()) {

      sedimentationCoefficient = 
	computeSedimentationCoefficient(parameters->getMassNumber(),
					parameters->getBuoyancyFactor(),
					parameters->getSolventViscosityNumber(),
					hydrodynamicRadius);

      sedimentationCoefficientComputed = true;
    }

    resultsZenoCompiled = true;
  }

  if (resultsInterior != NULL) {

    double boundingSphereVolume = boundingSphere.getVolume();

    double numInteriorSamples = resultsInterior->getNumSamples();

    numInteriorHits = resultsInterior->getNumHits();

    volume = computeVolume(numInteriorHits, numInteriorSamples,
			   boundingSphereVolume);

    capacitanceOfASphere = computeCapacitanceOfASphere(volume);

    Matrix3x3<Uncertain<double> > hitPointsSqrSum = 
      resultsInterior->getHitPointsSqrSum();

    Vector3<Uncertain<double> > hitPointsSum = 
      resultsInterior->getHitPointsSum();

    gyrationTensor = computeGyrationTensor(hitPointsSqrSum, 
					   hitPointsSum,
					   numInteriorHits);

    gyrationTensor.getEigenValues(gyrationEigenvalues);

    resultsInteriorCompiled = true;
  }

  if (resultsZeno != NULL &&
      resultsInterior != NULL) {

    intrinsicConductivity = computeIntrinsicConductivity(meanPolarizability,
							 volume);

    intrinsicViscosity = 
      computeIntrinsicViscosity(q_eta, intrinsicConductivity);
  }

  if (computeForm) {

    assert(resultsInterior != NULL);

    formFactorQs = computeFormFactorQs(boundingSphereRadius);

    formFactors = computeFormFactors(*(resultsInterior->getPoints()),
					       formFactorQs);

    formResultsCompiled = true;
  }
}

Uncertain<double> 
ResultsCompiler::
computeCapacitance(Uncertain<double> const & t, 
		   double boundingSphereRadius) const {

  Uncertain<double> capacitance = t * boundingSphereRadius;

  const double l = parameters->getLengthScaleNumber();

  capacitance *= l;

  return capacitance;
}

Matrix3x3<Uncertain<double> >
ResultsCompiler::
computePolarizability(Uncertain<double> const & t,
		      Vector3<Uncertain<double> > const & u,
		      Matrix3x3<Uncertain<double> > const & v,
		      Matrix3x3<Uncertain<double> > const & w,
		      double boundingSphereRadius) const {

  Matrix3x3<Uncertain<double> > polarizabilityTensor;

  for (int row = 0; row < 3; row++) {
    for (int col = 0; col < 3; col++) {
      Uncertain<double> element = 
	12*M_PI*pow(boundingSphereRadius, 2)*
	(w.get(row, col) - u.get(row)*v.get(row, col)/t);

      polarizabilityTensor.set(row, col, element);
    }
  }

  polarizabilityTensor.symmetrize();

  const double l = parameters->getLengthScaleNumber();

  polarizabilityTensor *= pow(l, 3);

  return polarizabilityTensor;
}

Uncertain<double>
ResultsCompiler::
computeMeanPolarizability(Matrix3x3<Uncertain<double> > const & 
			  polarizabilityTensor) 
  const {
  
  Uncertain<double> meanPolarizability = 
    (polarizabilityTensor.get(0, 0) +
     polarizabilityTensor.get(1, 1) +
     polarizabilityTensor.get(2, 2)) / 3.;

  return meanPolarizability;
}

Uncertain<double> 
ResultsCompiler::
computePadeApproximant(Matrix3x3<Uncertain<double> > const & 
		       polarizabilityTensor)
  const {

  Uncertain<double> alpha1 = polarizabilityTensor.get(0, 0);
  Uncertain<double> alpha2 = polarizabilityTensor.get(1, 1);
  Uncertain<double> alpha3 = polarizabilityTensor.get(2, 2);

  //sort
  if (alpha2 < alpha1) std::swap(alpha1, alpha2);
  if (alpha3 < alpha1) std::swap(alpha1, alpha3);
  if (alpha3 < alpha2) std::swap(alpha2, alpha3);

  Uncertain<double> alpha2_alpha1 = alpha2/alpha1;
  Uncertain<double> alpha3_alpha2 = alpha3/alpha2;

  if ((alpha2_alpha1 < 0.) ||
      (alpha3_alpha2 < 0.)) {

    std::cerr << "*** Warning ***" << std::endl
	      << "Could not compute Prefactor for computing intrinsic " 
	      << "viscosity, Viscometric radius, or Intrinsic viscosity.  "
	      << "This is likely due to Electrostatic polarizability tensor "
	      << "standard deviations being too high.  "
	      << "Try increasing the number of walks?" << std::endl
	      << std::endl;
  }

  Uncertain<double> x1 = log(alpha2_alpha1);
  Uncertain<double> x2 = log(alpha3_alpha2);

  Uncertain<double> q_eta = computePadeApproximant(x1, x2);

  q_eta = Uncertain<double>(q_eta.getMean(),
			    pow(q_eta.getMean() * 0.015, 2));

  return q_eta;
}

Uncertain<double> 
ResultsCompiler::
computePadeApproximant(Uncertain<double> x1, Uncertain<double> x2) const {
  const double delta_i[4] = {4.8,    0.66,  -1.247,  0.787};
  const double k_i[4]     = {0,      1.04,   2.012,  2.315};
  const double b_i[4]     = {0.68,  -7.399,  1.048,  0.136};
  const double t_i[4]     = {0,      1.063,  0.895,  4.993};
  const double B_i[4]     = {1.925, -8.611,  1.652, -0.120};
  const double q_i[4]     = {0,      1.344,  2.029,  1.075};
  const double c_i[4]     = {13.43,  16.17,  0.51,  -5.86};
  const double r_i[4]     = {0,      0.489,  0.879,  2.447};
  const double A_i[4]     = {16.23, -15.92,  14.83, -3.74};
  const double v_i[4]     = {0,      0.462,  1.989,  4.60};
  const double m_i[4]     = {2.786,  0.293, -0.11,   0.012};
  const double u_i[4]     = {0,      0.556,  2.034,  3.024};

  Uncertain<double> delta = 0;
  Uncertain<double> b     = 0;
  Uncertain<double> B     = 0;
  Uncertain<double> c     = 0;
  Uncertain<double> A     = 0;
  Uncertain<double> m     = 0;

  for (int i = 0; i < 4; i++) {
    delta += delta_i[i] * exp(-k_i[i] * x1);
    b     += b_i[i]     * exp(-t_i[i] * x1);
    B     += B_i[i]     * exp(-q_i[i] * x1);
    c     += c_i[i]     * exp(-r_i[i] * x1);
    A     += A_i[i]     * exp(-v_i[i] * x1);
    m     += m_i[i]     * exp(-u_i[i] * x1);
  }

  Uncertain<double> q_eta = 
    (delta*A + c*x2 + b*pow(x2, 2.) + 4.*pow(x2, m)) /
    (6.*A + 6.*c*x2/delta + B*pow(x2, 2.) + 5.*pow(x2, m));

  return q_eta;
}

Uncertain<double>
ResultsCompiler::
computeVolume(Uncertain<double> const & numInteriorHits, 
	      double numInteriorSamples,
	      double boundingSphereVolume) const {

  Uncertain<double> volume = 
    boundingSphereVolume * numInteriorHits / numInteriorSamples;

  const double l = parameters->getLengthScaleNumber();

  volume *= pow(l, 3);

  return volume;
}

Uncertain<double>
ResultsCompiler::
computeIntrinsicConductivity(Uncertain<double> const & meanPolarizability,
			     Uncertain<double> const & volume) const {

  Uncertain<double> intrinsicConductivity = meanPolarizability / volume;

  return intrinsicConductivity;
}

Uncertain<double> 
ResultsCompiler::
computeCapacitanceOfASphere(Uncertain<double> const & volume) const {

  Uncertain<double> capacitanceOfASphere = pow(3.*volume/(4.*M_PI), 1./3.);

  return capacitanceOfASphere;
}

Uncertain<double> 
ResultsCompiler::
computeHydrodynamicRadius(Uncertain<double> const & capacitance) const {

  Uncertain<double> q_Rh(1, pow(0.01, 2));

  Uncertain<double> hydrodynamicRadius = q_Rh * capacitance;

  return hydrodynamicRadius;
}

Uncertain<double> 
ResultsCompiler::
computeViscometricRadius(Uncertain<double> const & meanPolarizability,
			 Uncertain<double> const & padeApproximant) const {

  Uncertain<double> alpha = meanPolarizability;
  Uncertain<double> q_eta = padeApproximant;

  Uncertain<double> viscometricRadius = pow((3.*q_eta*alpha)/(10.*M_PI), 1./3.);

  return viscometricRadius;
}

Uncertain<double> 
ResultsCompiler::
computeIntrinsicViscosity(Uncertain<double> const & padeApproximant,
			  Uncertain<double> const & intrinsicConductivity) 
  const {

  Uncertain<double> intrinsicViscosity = 
    padeApproximant * intrinsicConductivity;

  return intrinsicViscosity;
}

Uncertain<double>
ResultsCompiler::
computeIntrinsicViscosityConventional
(Uncertain<double> const & padeApproximant,
 Uncertain<double> const & meanPolarizability,
 double mass) const {

  Uncertain<double> intrinsicViscosityConventional =
    padeApproximant * meanPolarizability / mass;

  if (parameters->getLengthScaleUnit() != Units::Length::L) {
    const Uncertain<double> a_l = 
      Units::getFactor(parameters->getLengthScaleUnit(), 
		       Units::Length::cm);

    const Uncertain<double> a_m = 
      Units::getFactor(parameters->getMassUnit(), 
		       Units::Mass::g);

    intrinsicViscosityConventional *= pow(a_l, 3.) * a_m;	
  }

  return intrinsicViscosityConventional;
}

Uncertain<double>
ResultsCompiler::
computeFrictionCoefficient(double solventViscosity,
			   Uncertain<double> const & hydrodynamicRadius) const {

  Uncertain<double> frictionCoefficient = 
    6 * M_PI * solventViscosity * hydrodynamicRadius;

  const Uncertain<double> a_l =
    Units::getFactor(parameters->getLengthScaleUnit(),
                     Units::Length::cm);

  const Uncertain<double> a_eta =
    Units::getFactor(parameters->getSolventViscosityUnit(),
		     Units::Viscosity::cp);

  frictionCoefficient *= pow(10, -2) * a_l * a_eta;

  return frictionCoefficient;
}

Uncertain<double>
ResultsCompiler::
computeDiffusionCoefficient(double temperature,
			    double solventViscosity,
			    Uncertain<double> const & hydrodynamicRadius) 
  const {

  const Uncertain<double> a_T =
    Units::getOffset(parameters->getTemperatureUnit(),
		     Units::Temperature::K);

  const Uncertain<double> k_B = Units::kB();

  Uncertain<double> diffusionCoefficient = 
    k_B * (temperature + a_T) / 
    (6 * M_PI * solventViscosity * hydrodynamicRadius);

  const Uncertain<double> a_l =
    Units::getFactor(parameters->getLengthScaleUnit(),
                     Units::Length::cm);

  const Uncertain<double> a_eta =
    Units::getFactor(parameters->getSolventViscosityUnit(),
		     Units::Viscosity::cp);

  diffusionCoefficient *= 
    pow(10, 9) * pow(a_l, -1.) * pow(a_eta, -1.);

  return diffusionCoefficient;
}

Uncertain<double>
ResultsCompiler::
computeSedimentationCoefficient(double mass,
				double buoyancyFactor,
				double solventViscosity,
				Uncertain<double> const & hydrodynamicRadius) 
  const {

  Uncertain<double> sedimentationCoefficient = 
    mass * buoyancyFactor / 
    (6 * M_PI * solventViscosity * hydrodynamicRadius);

  const Uncertain<double> a_l =
    Units::getFactor(parameters->getLengthScaleUnit(),
                     Units::Length::cm);

  const Uncertain<double> a_eta =
    Units::getFactor(parameters->getSolventViscosityUnit(),
		     Units::Viscosity::cp);

  const Uncertain<double> a_m =
    Units::getFactor(parameters->getMassUnit(),
		     Units::Mass::g);

  sedimentationCoefficient *= 
    pow(10, 15) * pow(a_l, -1.) * pow(a_eta, -1.) * pow(a_m, -1.);

  return sedimentationCoefficient;
}

Matrix3x3<Uncertain<double> >
ResultsCompiler::
computeGyrationTensor(Matrix3x3<Uncertain<double> > const & hitPointsSqrSum,
		      Vector3<Uncertain<double> > const & hitPointsSum,
		      Uncertain<double> const & numInteriorHits) const {

  Matrix3x3<Uncertain<double> > hitPointsSumSqr;

  for (int row = 0; row < 3; ++row) {
    for (int col = 0; col < 3; ++col) {
      Uncertain<double> element = 
	hitPointsSum.get(row) * hitPointsSum.get(col);

      hitPointsSumSqr.set(row, col, element);
    }
  }

  Matrix3x3<Uncertain<double> > gyrationTensor =
    hitPointsSqrSum / numInteriorHits - 
    hitPointsSumSqr / pow(numInteriorHits, 2.);

  const double l = parameters->getLengthScaleNumber();

  gyrationTensor *= pow(l, 2);

  return gyrationTensor;
}

std::array<double, ResultsCompiler::numFormFactors>
ResultsCompiler::
computeFormFactorQs(double boundingSphereRadius) const {

  const double l = parameters->getLengthScaleNumber();

  std::array<double, numFormFactors> qs;

  for (unsigned int factorNum = 0; 
       factorNum < numFormFactors; 
       ++factorNum) {

    qs.at(factorNum) =
      0.01 * pow(10000, (double)factorNum/(numFormFactors - 1)) /
      boundingSphereRadius;

    qs.at(factorNum) *= pow(l, -1);
  }

  return qs;
}

std::array<double, ResultsCompiler::numFormFactors>
ResultsCompiler::
computeFormFactors(std::vector<Vector3<double> > const & interiorPoints,
			std::array<double, 
			ResultsCompiler::numFormFactors> const & 
			formFactorQs) const {

  BigUInt numPairs = 
    (interiorPoints.size() * interiorPoints.size() - 
     interiorPoints.size()) / 2;

  BigUInt numPairsInProcess = numPairs;

  int numThreads = parameters->getNumThreads(); 

  std::vector<std::array<double, numFormFactors> > threadsFormFactors;

  threadsFormFactors.reserve(numThreads);

  std::vector<std::thread> threads;

  threads.reserve(numThreads);

  BigUInt threadStartPairIndex = 0;

  for (int threadNum = 0; threadNum < numThreads; ++threadNum) {
    BigUInt numPairsInThread = numPairsInProcess / numThreads;

    if ((unsigned int)threadNum < numPairsInProcess % numThreads) {
      numPairsInThread ++;
    }

    BigUInt threadEndPairIndex = threadStartPairIndex + numPairsInThread;

    threads.emplace_back(&ResultsCompiler::computeFormFactorsThread,
			 this,
			 threadNum,
			 interiorPoints,
			 formFactorQs,
			 threadStartPairIndex,
			 threadEndPairIndex,
			 &(threadsFormFactors[threadNum]));

    threadStartPairIndex += numPairsInThread;
  }

  for (int threadNum = 0; threadNum < numThreads; ++threadNum) {
    threads.at(threadNum).join();
  }

  std::array<double, numFormFactors> formFactorsReduced;

  formFactorsReduced.fill(0);

  for (int threadNum = 0; 
       threadNum < numThreads; 
       ++threadNum) {

    for (unsigned int factorNum = 0; 
	 factorNum < numFormFactors; 
	 ++factorNum) {

      formFactorsReduced.at(factorNum) += 
	threadsFormFactors[threadNum].at(factorNum);
    }
  }

  for (unsigned int factorNum = 0; 
       factorNum < numFormFactors; 
       ++factorNum) {

    formFactorsReduced.at(factorNum) /= numPairs;
  }

  return formFactorsReduced;
}

void
ResultsCompiler::
computeFormFactorsThread(int threadNum,
			      std::vector<Vector3<double> > const & 
			      interiorPoints,
			      std::array<double, 
			      ResultsCompiler::numFormFactors> const & 
			      formFactorQs,
			      BigUInt startPairIndex,
			      BigUInt endPairIndex,
			      std::array<double, numFormFactors> * 
			      threadFormFactors) const {

  const double l = parameters->getLengthScaleNumber();

  threadFormFactors->fill(0);

  for (BigUInt pairIndex = startPairIndex;
       pairIndex < endPairIndex;
       ++pairIndex) {

    BigUInt i = 0, j = 0;

    indexToIJ(pairIndex, &i, &j);

    double distance = 
      (interiorPoints.at(i) - 
       interiorPoints.at(j)).getMagnitude();

    distance *= l;

    for (unsigned int factorNum = 0; 
	 factorNum < numFormFactors; 
	 ++factorNum) {

      double q = formFactorQs.at(factorNum);

      double divisor = q*distance;

      //use Taylor expansion of sin(x)/x for small x
      if (divisor < 0.001) {
	threadFormFactors->at(factorNum) +=
	  1. - pow(divisor, 2)/6.;
      }
      else {
	threadFormFactors->at(factorNum) += 
	  sin(divisor)/divisor;
      }
    }
  }
}

/// Inverts the formula: 
/// index = (j*j + j)/2 + i
///
void 
ResultsCompiler::
indexToIJ(BigUInt index, BigUInt * i, BigUInt * j) const {

  (*j) = round(sqrt(2*index + 1)) - 1;
  (*i) = index - ((*j)*(*j) + (*j))/2;

  ++(*j);
}

/// Print the computed physical quantities.  Optionally also print the raw
/// hit counts.
///
void 
ResultsCompiler::
print(bool printCounts) const {

  if (resultsZenoCompiled) {

    zeno_cxx_fout->ofs << std::scientific
	      << "Capacitance (" 
	      << Units::getName(parameters->getLengthScaleUnit()) 
	      << "): " << capacitance << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Electric polarizability tensor ("
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "^3): " << std::endl
	      << polarizabilityTensor 
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Eigenvalues of electric polarizability tensor (" 
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "^3): " << std::endl
	      << polarizabilityEigenvalues << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Mean electric polarizability (" 
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "^3): " << meanPolarizability << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Hydrodynamic radius ("
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "): " << hydrodynamicRadius << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Prefactor for computing intrinsic viscosity: " 
	      << q_eta << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Viscometric radius (" 
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "): " << viscometricRadius << std::endl
	      << std::endl;

    if (intrinsicViscosityConventionalComputed) {

      zeno_cxx_fout->ofs << "Intrinsic viscosity with mass units (";

      if (parameters->getLengthScaleUnit() == Units::Length::L) {

	zeno_cxx_fout->ofs << Units::getName(parameters->getLengthScaleUnit())
		  << "^3/"
		  << Units::getName(parameters->getMassUnit());
      }
      else {

	zeno_cxx_fout->ofs << "cm^3/g";
      }

      zeno_cxx_fout->ofs << std::scientific
		<< "): " << intrinsicViscosityConventional << std::endl
		<< std::endl;
    }

    if (frictionCoefficientComputed) {

      zeno_cxx_fout->ofs << std::scientific
		<< "Friction coefficient (d.s/cm): " 
		<< frictionCoefficient << std::endl
		<< std::endl;
    }

    if (diffusionCoefficientComputed) {

      zeno_cxx_fout->ofs << std::scientific
		<< "Diffusion coefficient (cm^2/s): "
		<< diffusionCoefficient << std::endl
		<< std::endl;
    }

    if (sedimentationCoefficientComputed) {

      zeno_cxx_fout->ofs << std::scientific
		<< "Sedimentation coefficient (Sved): "
		<< sedimentationCoefficient << std::endl
		<< std::endl;
    }
  }

  if (resultsInteriorCompiled) {

    zeno_cxx_fout->ofs << std::scientific
	      << "Volume (" 
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "^3): " << volume << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Capacitance of a sphere of the same volume ("
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "): " << capacitanceOfASphere << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Gyration tensor ("
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "^2): " << std::endl
	      << gyrationTensor 
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Eigenvalues of gyration tensor (" 
	      << Units::getName(parameters->getLengthScaleUnit())
	      << "^2): " << std::endl
	      << gyrationEigenvalues << std::endl
	      << std::endl;
  }

  if (resultsZenoCompiled && resultsInteriorCompiled) {

    zeno_cxx_fout->ofs << std::scientific
	      << "Intrinsic conductivity: " << intrinsicConductivity 
	      << std::endl
	      << std::endl;

    zeno_cxx_fout->ofs << std::scientific
	      << "Intrinsic viscosity: " << intrinsicViscosity 
	      << std::endl
	      << std::endl;
  }

  if (formResultsCompiled) {

    zeno_cxx_fout->ofs << "Form factor: " << std::endl;

    for (unsigned int factorNum = 0; 
	 factorNum < numFormFactors;
	 ++factorNum) {

      zeno_cxx_fout->ofs << std::scientific
		<< formFactorQs.at(factorNum) << " ("
		<< Units::getName(parameters->getLengthScaleUnit())
		<< "^-1): "
		<< formFactors.at(factorNum) << std::endl;
    }

    zeno_cxx_fout->ofs << std::endl;
  }

  if (printCounts) {

    zeno_cxx_fout->ofs << std::scientific
	      << "Counts:" << std::endl
	      << std::endl
	      << "t: " << t << std::endl
	      << std::endl
	      << "u: " << u << std::endl
	      << std::endl
	      << "v: " << std::endl << v
	      << std::endl
	      << "w: " << std::endl << w
	      << std::endl
	      << "Interior hits: " << numInteriorHits << std::endl
	      << std::endl;
  }
}

Uncertain<double> 
ResultsCompiler::
getCapacitance() const {

  assert(resultsZenoCompiled);

  return capacitance;
}

Uncertain<double> 
ResultsCompiler::
getMeanPolarizability() const {

  assert(resultsZenoCompiled);

  return meanPolarizability;
}

Uncertain<double> 
ResultsCompiler::
getVolume() const {

  assert(resultsInteriorCompiled);

  return volume;
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// mode: c++
// End:

// *** END *** ResultsCompiler.cc ***

// *** START *** ResultsInterior.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Wed Apr 22 11:11:48 2015 EDT
//
// Time-stamp: <2016-08-29 16:20:36 dcj>
//
// ================================================================

#ifdef USE_MPI
#include <mpi.h>
#endif

#include <cassert>
#include <cstdlib>

// inlined #include "ResultsInterior.h"

// ================================================================

/// Constructs the class to collect results from the given number of threads,
/// and optionally save the hit point locations.
///
ResultsInterior::
ResultsInterior(int numThreads,
		bool saveHitPoints)
  : numThreads(numThreads),
    saveHitPoints(saveHitPoints),
    numSamples(NULL),
    hitMissMean(NULL),
    hitMissM2(NULL),
    hitPointsSqrMean(NULL),
    hitPointsSqrM2(NULL),
    hitPointsMean(NULL),
    hitPointsM2(NULL),
    numSamplesReduced(0),
    numHitsReduced(0),
    numHitsVarianceReduced(0),
    hitPointsSqrSumReduced(0, 0, 0, 
			   0, 0, 0, 
			   0, 0, 0),
    hitPointsSqrSumVarianceReduced(0, 0, 0, 
				   0, 0, 0, 
				   0, 0, 0),
    hitPointsSumReduced(0, 0, 0),
    hitPointsSumVarianceReduced(0, 0, 0),
    points(NULL),
    gatheredPoints(),
    reduced(true),
    hitPointsGathered(true) {

  numSamples = new double[numThreads];

  hitMissMean = new double[numThreads];
  hitMissM2   = new double[numThreads];

  hitPointsSqrMean = new Matrix3x3<double>[numThreads];
  hitPointsSqrM2   = new Matrix3x3<double>[numThreads];

  hitPointsMean = new Vector3<double>[numThreads];
  hitPointsM2   = new Vector3<double>[numThreads];

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    numSamples[threadNum] = 0;

    hitMissMean[threadNum] = 0;
    hitMissM2[threadNum]   = 0;

    for (int component = 0; component < 3*3; component++) {
      hitPointsSqrMean[threadNum].set(component, 0);
      hitPointsSqrM2[threadNum].set(component, 0);
    }

    hitPointsMean[threadNum].setXYZ(0, 0, 0);
    hitPointsM2[threadNum].setXYZ(0, 0, 0);
  }

  points = new std::vector<Vector3<double> >[numThreads];
}

ResultsInterior::
~ResultsInterior() {
  delete [] numSamples;

  delete [] hitMissMean;
  delete [] hitMissM2;

  delete [] hitPointsSqrMean;
  delete [] hitPointsSqrM2;

  delete [] hitPointsMean;
  delete [] hitPointsM2;
}

/// Record a hit from the given thread number at the given location.
///
void 
ResultsInterior::
recordHit(int threadNum,
	  Vector3<double> const & point) {

  assert(threadNum >= 0 && threadNum < numThreads);

  reduced = false;

  numSamples[threadNum] ++;

  double hitMissData = 1;

  Matrix3x3<double> hitPointsSqrData;

  for (int row = 0; row < 3; ++row) {
    for (int col = 0; col < 3; ++col) {
      double element = point.get(row) * point.get(col);

      hitPointsSqrData.set(row, col, element);
    }
  }

  Vector3<double> hitPointsData(point);

  updateVariance(threadNum,
		 hitMissData,
		 hitPointsSqrData,
		 hitPointsData);

  if (saveHitPoints) {
    hitPointsGathered = false;

    points[threadNum].push_back(point);
  }
}

/// Record a miss from the given thread number.
///
void 
ResultsInterior::
recordMiss(int threadNum) {
  assert(threadNum >= 0 && threadNum < numThreads);

  reduced = false;

  numSamples[threadNum] ++;

  double hitMissData = 0;

  Matrix3x3<double> hitPointsSqrData(0, 0, 0,
				     0, 0, 0,
				     0, 0, 0);

  Vector3<double> hitPointsData(0, 0, 0);

  updateVariance(threadNum, 
		 hitMissData,
		 hitPointsSqrData,
		 hitPointsData);
}

/// Perform a parallel reduction on the hit counts and locations and 
/// corresponding variances across threads and MPI nodes.
///
void 
ResultsInterior::
reduce() {
  if (reduced) {
    return;
  }

  numSamplesReduced = 0;

  numHitsReduced         = 0;
  numHitsVarianceReduced = 0;

  for (int component = 0; component < 3*3; component++) {
    hitPointsSqrSumReduced.set(component, 0);
    hitPointsSqrSumVarianceReduced.set(component, 0);
  }

  hitPointsSumReduced.setXYZ(0, 0, 0);
  hitPointsSumVarianceReduced.setXYZ(0, 0, 0);

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {

    numSamplesReduced += numSamples[threadNum];

    reduceItem(hitMissMean[threadNum],
	       hitMissM2[threadNum],
	       numSamples[threadNum],
	       &numHitsReduced,
	       &numHitsVarianceReduced);

    reduceItem(hitPointsSqrMean[threadNum],
	       hitPointsSqrM2[threadNum],
	       numSamples[threadNum],
	       &hitPointsSqrSumReduced,
	       &hitPointsSqrSumVarianceReduced);

    reduceItem(hitPointsMean[threadNum],
	       hitPointsM2[threadNum],
	       numSamples[threadNum],
	       &hitPointsSumReduced,
	       &hitPointsSumVarianceReduced);
  }

#ifdef USE_MPI
  const int mpiBufferSize = 27; 

  double sendbuf[mpiBufferSize];

  int offset = 0;

  sendbuf[offset++] = numSamplesReduced;

  sendbuf[offset++] = numHitsReduced;
  sendbuf[offset++] = numHitsVarianceReduced;

  for (int i = 0; i < 9; i++) {
    sendbuf[offset++] = hitPointsSqrSumReduced.get(i);
    sendbuf[offset++] = hitPointsSqrSumVarianceReduced.get(i);
  }

  for (int i = 0; i < 3; i++) {
    sendbuf[offset++] = hitPointsSumReduced.get(i);
    sendbuf[offset++] = hitPointsSumVarianceReduced.get(i);
  }

  double recvbuf[mpiBufferSize];

  for (int i = 0; i < mpiBufferSize; i++) {
    recvbuf[i] = 0;
  }

  // MPI_Reduce(sendbuf, recvbuf, mpiBufferSize, MPI_DOUBLE,
  // 	     MPI_SUM, 0, MPI_COMM_WORLD);

  MPI_Allreduce(sendbuf, recvbuf, mpiBufferSize, MPI_DOUBLE,
		MPI_SUM, MPI_COMM_WORLD);

  offset = 0;

  numSamplesReduced = recvbuf[offset++];

  numHitsReduced         = recvbuf[offset++];
  numHitsVarianceReduced = recvbuf[offset++];

  for (int i = 0; i < 9; i++) {
    hitPointsSqrSumReduced.set(i, recvbuf[offset++]);
    hitPointsSqrSumVarianceReduced.set(i, recvbuf[offset++]);
  }

  for (int i = 0; i < 3; i++) {
    hitPointsSumReduced.set(i, recvbuf[offset++]);
    hitPointsSumVarianceReduced.set(i, recvbuf[offset++]);
  }
#endif

  reduced = true;
}

/// Gather the hit locations from all threads and MPI nodes.
///
void 
ResultsInterior::
gatherHitPoints() {
  if (hitPointsGathered) {
    return;
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    gatheredPoints.insert(gatheredPoints.end(), 
			 points[threadNum].begin(), 
			 points[threadNum].end());
  }

#ifdef USE_MPI
  int mpiSize = 0;
  int mpiRank = 0;

  MPI_Comm_size(MPI_COMM_WORLD, &mpiSize);
  MPI_Comm_rank(MPI_COMM_WORLD, &mpiRank);

  int * arrayLengths = new int[mpiSize];

  int arrayLength = gatheredPoints.size() * 3;

  MPI_Allgather(&arrayLength, 1, MPI_INT,
		arrayLengths, 1, MPI_INT,
		MPI_COMM_WORLD);

  int combinedArrayLength = 0;

  for (int i = 0; i < mpiSize; i++) {
    combinedArrayLength += arrayLengths[i];
  }

  double * combinedPointArray  = new double[combinedArrayLength];

  int * combinedArrayOffsets = new int[mpiSize];

  combinedArrayOffsets[0] = 0;

  for (int i = 1; i < mpiSize; i++) {
    combinedArrayOffsets[i] = combinedArrayOffsets[i - 1] + arrayLengths[i - 1];
  }

  double * pointArray  = new double[arrayLengths[mpiRank]];

  for (int index = 0; index < arrayLengths[mpiRank]; index++) {
    pointArray[index] = gatheredPoints[index / 3].get(index % 3);
  }

  MPI_Allgatherv(pointArray, 
		 arrayLengths[mpiRank], MPI_DOUBLE,
		 combinedPointArray, 
		 arrayLengths, combinedArrayOffsets, MPI_DOUBLE,
		 MPI_COMM_WORLD);

  gatheredPoints.clear( );

  gatheredPoints.reserve(combinedArrayLength / 3);
  
  for (int index = 0; index < combinedArrayLength; index += 3) {
    gatheredPoints.emplace_back(combinedPointArray[index + 0],
				combinedPointArray[index + 1],
				combinedPointArray[index + 2]);
  }

  delete [] arrayLengths;

  delete [] combinedPointArray;

  delete [] combinedArrayOffsets;

  delete [] pointArray;
#endif

  hitPointsGathered = true;
}

Uncertain<double> 
ResultsInterior::
getNumHits() const {
  assert(reduced);

  return Uncertain<double>(numHitsReduced, numHitsVarianceReduced);
}

Matrix3x3<Uncertain<double> > 
ResultsInterior::
getHitPointsSqrSum() const {
  assert(reduced);

  return Uncertain<double>::zip(hitPointsSqrSumReduced, 
				hitPointsSqrSumVarianceReduced);
}

Vector3<Uncertain<double> > 
ResultsInterior::
getHitPointsSum() const {
  assert(reduced);

  return Uncertain<double>::zip(hitPointsSumReduced, 
				hitPointsSumVarianceReduced);
}

double
ResultsInterior::
getNumSamples() const {
  assert(reduced);

  return numSamplesReduced;
}

bool
ResultsInterior::
getSaveHitPoints() const {

  return saveHitPoints;
}

std::vector<Vector3<double> > const * 
ResultsInterior::
getPoints() const {
  assert(saveHitPoints);
  assert(hitPointsGathered);

  return &gatheredPoints;
}

void 
ResultsInterior::
updateVariance(int threadNum,
	       double hitMissData,
	       Matrix3x3<double> const & hitPointsSqrData,
	       Vector3<double> const & hitPointsData) {

  updateItemVariance(hitMissData,
		     numSamples[threadNum],
		     &(hitMissMean[threadNum]),
		     &(hitMissM2[threadNum]));

  updateItemVariance(hitPointsSqrData,
		     numSamples[threadNum],
		     &(hitPointsSqrMean[threadNum]),
		     &(hitPointsSqrM2[threadNum]));

  updateItemVariance(hitPointsData,
		     numSamples[threadNum],
		     &(hitPointsMean[threadNum]),
		     &(hitPointsM2[threadNum]));
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// mode: c++
// End:

// *** END *** ResultsInterior.cc ***

// *** START *** ResultsZeno.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Wed Apr 22 11:11:48 2015 EDT
//
// Time-stamp: <2016-08-29 17:05:58 dcj>
//
// ================================================================

// inlined #include "ResultsZeno.h"

#ifdef USE_MPI
#include <mpi.h>
#endif

/// Constructs the class to collect results with the given bounding sphere 
/// from the given number of threads,
/// and optionally save the hit point locations.
///
ResultsZeno::
ResultsZeno(Sphere<double> const & boundingSphere,
	    int numThreads,
	    bool saveHitPoints) 
  : boundingSphereRadius(boundingSphere.getRadius()),
    boundingSphereCenter(boundingSphere.getCenter()),
    numThreads(numThreads),
    saveHitPoints(saveHitPoints),
    numWalks(NULL),
    hitMissMean(NULL),
    hitMissM2(NULL),
    KPlus(NULL),
    KMinus(NULL),
    KPlusMean(NULL),
    KMinusMean(NULL),
    KPlusM2(NULL),
    KMinusM2(NULL),
    VPlus(NULL),
    VMinus(NULL),
    VPlusMean(NULL),
    VMinusMean(NULL),
    VPlusM2(NULL),
    VMinusM2(NULL),
    numWalksReduced(0),
    numHitsReduced(0),
    numHitsVarianceReduced(0),
    KPlusReduced(0, 0, 0),
    KMinusReduced(0, 0, 0),
    VPlusReduced(0, 0, 0, 
		 0, 0, 0, 
		 0, 0, 0),
    VMinusReduced(0, 0, 0, 
		  0, 0, 0, 
		  0, 0, 0),
    points(NULL),
    normals(NULL),
    charges(NULL),
    gatheredPoints(),
    gatheredNormals(),
    gatheredCharges(),
    reduced(true),
    hitPointsGathered(true) {

  numWalks = new double[numThreads];

  hitMissMean = new double[numThreads];

  hitMissM2 = new double[numThreads];

  KPlus  = new Vector3<double>[numThreads];
  KMinus = new Vector3<double>[numThreads];

  KPlusMean  = new Vector3<double>[numThreads];
  KMinusMean = new Vector3<double>[numThreads];  

  KPlusM2  = new Vector3<double>[numThreads];
  KMinusM2 = new Vector3<double>[numThreads];

  VPlus  = new Matrix3x3<double>[numThreads];
  VMinus = new Matrix3x3<double>[numThreads];

  VPlusMean  = new Matrix3x3<double>[numThreads];
  VMinusMean = new Matrix3x3<double>[numThreads];

  VPlusM2  = new Matrix3x3<double>[numThreads];
  VMinusM2 = new Matrix3x3<double>[numThreads];

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    numWalks[threadNum] = 0;

    hitMissMean[threadNum] = 0;

    hitMissM2[threadNum] = 0;

    KPlus[threadNum].setXYZ(0, 0, 0);
    KMinus[threadNum].setXYZ(0, 0, 0);

    KPlusMean[threadNum].setXYZ(0, 0, 0);
    KMinusMean[threadNum].setXYZ(0, 0, 0);

    KPlusM2[threadNum].setXYZ(0, 0, 0);
    KMinusM2[threadNum].setXYZ(0, 0, 0);

    for (int component = 0; component < 3*3; component++) {
      VPlus[threadNum].set(component, 0);
      VMinus[threadNum].set(component, 0);

      VPlusMean[threadNum].set(component, 0);
      VMinusMean[threadNum].set(component, 0);

      VPlusM2[threadNum].set(component, 0);
      VMinusM2[threadNum].set(component, 0);
    }
  }

  points  = new std::vector<Vector3<double> >[numThreads];
  normals = new std::vector<Vector3<double> >[numThreads];
  charges = new std::vector<Vector3<char> >[numThreads];
}

ResultsZeno::
~ResultsZeno() {
  delete [] numWalks;

  delete [] hitMissMean;

  delete [] hitMissM2;

  delete [] KPlus;
  delete [] KMinus;

  delete [] KPlusMean;
  delete [] KMinusMean;

  delete [] KPlusM2;
  delete [] KMinusM2;

  delete [] VPlus;
  delete [] VMinus;

  delete [] VPlusMean;
  delete [] VMinusMean;

  delete [] VPlusM2;
  delete [] VMinusM2;

  delete [] points;
  delete [] normals;
  delete [] charges;
}

/// Record a miss from the given thread number.
///
void 
ResultsZeno::
recordMiss(int threadNum) {
  assert(threadNum >= 0 && threadNum < numThreads);

  reduced = false;

  double hitMissData = 0;

  Vector3<double> KPlusData(0, 0, 0);
  Vector3<double> KMinusData(0, 0, 0);

  Matrix3x3<double> VPlusData(0, 0, 0, 0, 0, 0, 0, 0, 0);
  Matrix3x3<double> VMinusData(0, 0, 0, 0, 0, 0, 0, 0, 0);

  numWalks[threadNum]++;

  updateVariance(threadNum,
		 hitMissData,
		 KPlusData, 
		 KMinusData,
		 VPlusData, 
		 VMinusData);
}

/// Perform a parallel reduction on the hit counts and other statistics and 
/// corresponding variances across threads and MPI nodes.
///
void 
ResultsZeno::
reduce() {
  if (reduced) {
    return;
  }

  numWalksReduced = 0;

  numHitsReduced = 0;

  numHitsVarianceReduced = 0;

  KPlusReduced.setXYZ(0, 0, 0);
  KMinusReduced.setXYZ(0, 0, 0);

  KPlusVarianceReduced.setXYZ(0, 0, 0);
  KMinusVarianceReduced.setXYZ(0, 0, 0);

  for (int component = 0; component < 3*3; component++) {
    VPlusReduced.set(component, 0);
    VMinusReduced.set(component, 0);

    VPlusVarianceReduced.set(component, 0);
    VMinusVarianceReduced.set(component, 0);
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    const double nn1 = (double)numWalks[threadNum] / (numWalks[threadNum] - 1);

    numWalksReduced += numWalks[threadNum];

    numHitsReduced += hitMissMean[threadNum] * numWalks[threadNum];

    numHitsVarianceReduced += hitMissM2[threadNum] * nn1;

    KPlusReduced  += KPlus[threadNum];
    KMinusReduced += KMinus[threadNum];

    KPlusVarianceReduced  += KPlusM2[threadNum] * nn1;
    KMinusVarianceReduced += KMinusM2[threadNum] * nn1;

    VPlusReduced  += VPlus[threadNum];
    VMinusReduced += VMinus[threadNum];

    VPlusVarianceReduced  += VPlusM2[threadNum] * nn1;
    VMinusVarianceReduced += VMinusM2[threadNum] * nn1;
  }

#ifdef USE_MPI
  const int mpiBufferSize = 51;

  double sendbuf[mpiBufferSize];

  int offset = 0;

  sendbuf[offset++] = numWalksReduced;

  sendbuf[offset++] = numHitsReduced;
  sendbuf[offset++] = numHitsVarianceReduced;

  for (int i = 0; i < 3; i++) {
    sendbuf[offset++] = KPlusReduced.get(i);
    sendbuf[offset++] = KPlusVarianceReduced.get(i);
  }

  for (int i = 0; i < 3; i++) {
    sendbuf[offset++] = KMinusReduced.get(i);
    sendbuf[offset++] = KMinusVarianceReduced.get(i);
  }

  for (int i = 0; i < 9; i++) {
    sendbuf[offset++] = VPlusReduced.get(i);
    sendbuf[offset++] = VPlusVarianceReduced.get(i);
  }

  for (int i = 0; i < 9; i++) {
    sendbuf[offset++] = VMinusReduced.get(i);
    sendbuf[offset++] = VMinusVarianceReduced.get(i);
  }

  double recvbuf[mpiBufferSize];

  for (int i = 0; i < mpiBufferSize; i++) {
    recvbuf[i] = 0;
  }

  // MPI_Reduce(sendbuf, recvbuf, mpiBufferSize, MPI_DOUBLE,
  // 	     MPI_SUM, 0, MPI_COMM_WORLD);

  MPI_Allreduce(sendbuf, recvbuf, mpiBufferSize, MPI_DOUBLE,
		MPI_SUM, MPI_COMM_WORLD);

  offset = 0;

  numWalksReduced = recvbuf[offset++];

  numHitsReduced         = recvbuf[offset++];
  numHitsVarianceReduced = recvbuf[offset++];

  for (int i = 0; i < 3; i++) {
    KPlusReduced.set(i, recvbuf[offset++]);
    KPlusVarianceReduced.set(i, recvbuf[offset++]);
  }

  for (int i = 0; i < 3; i++) {
    KMinusReduced.set(i, recvbuf[offset++]);
    KMinusVarianceReduced.set(i, recvbuf[offset++]);
  }

  for (int i = 0; i < 9; i++) {
    VPlusReduced.set(i, recvbuf[offset++]);
    VPlusVarianceReduced.set(i, recvbuf[offset++]);
  }

  for (int i = 0; i < 9; i++) {
    VMinusReduced.set(i, recvbuf[offset++]);
    VMinusVarianceReduced.set(i, recvbuf[offset++]);
  }
#endif

  reduced = true;
}

/// Gather the hit locations from all threads and MPI nodes.
///
void 
ResultsZeno::
gatherHitPoints() {
  if (hitPointsGathered) {
    return;
  }

  for (int threadNum = 0; threadNum < numThreads; threadNum++) {
    gatheredPoints.insert(gatheredPoints.end(), 
			 points[threadNum].begin(), 
			 points[threadNum].end());

    gatheredNormals.insert(gatheredNormals.end(),
			  normals[threadNum].begin(),
			  normals[threadNum].end());

    gatheredCharges.insert(gatheredCharges.end(),
			  charges[threadNum].begin(),
			  charges[threadNum].end());
  }

#ifdef USE_MPI
  int mpiSize = 0;
  int mpiRank = 0;

  MPI_Comm_size(MPI_COMM_WORLD, &mpiSize);
  MPI_Comm_rank(MPI_COMM_WORLD, &mpiRank);

  int * arrayLengths = new int[mpiSize];

  int arrayLength = gatheredPoints.size() * 3;

  MPI_Allgather(&arrayLength, 1, MPI_INT,
		arrayLengths, 1, MPI_INT,
		MPI_COMM_WORLD);

  int combinedArrayLength = 0;

  for (int i = 0; i < mpiSize; i++) {
    combinedArrayLength += arrayLengths[i];
  }

  double * combinedPointArray  = new double[combinedArrayLength];
  double * combinedNormalArray = new double[combinedArrayLength];
  char *   combinedChargeArray = new char[combinedArrayLength];

  int * combinedArrayOffsets = new int[mpiSize];

  combinedArrayOffsets[0] = 0;

  for (int i = 1; i < mpiSize; i++) {
    combinedArrayOffsets[i] = combinedArrayOffsets[i - 1] + arrayLengths[i - 1];
  }

  double * pointArray  = new double[arrayLengths[mpiRank]];
  double * normalArray = new double[arrayLengths[mpiRank]];
  char *   chargeArray = new char[arrayLengths[mpiRank]];

  for (int index = 0; index < arrayLengths[mpiRank]; index++) {
    pointArray[index]  = gatheredPoints[index / 3].get(index % 3);
    normalArray[index] = gatheredNormals[index / 3].get(index % 3);
    chargeArray[index] = gatheredCharges[index / 3].get(index % 3);
  }

  MPI_Allgatherv(pointArray, 
		 arrayLengths[mpiRank], MPI_DOUBLE,
		 combinedPointArray, 
		 arrayLengths, combinedArrayOffsets, MPI_DOUBLE,
		 MPI_COMM_WORLD);

  MPI_Allgatherv(normalArray, 
		 arrayLengths[mpiRank], MPI_DOUBLE,
		 combinedNormalArray, 
		 arrayLengths, combinedArrayOffsets, MPI_DOUBLE,
		 MPI_COMM_WORLD);

  MPI_Allgatherv(chargeArray,
		 arrayLengths[mpiRank], MPI_BYTE,
		 combinedChargeArray,
		 arrayLengths, combinedArrayOffsets, MPI_BYTE,
		 MPI_COMM_WORLD);

  gatheredPoints.clear( );
  gatheredNormals.clear( );
  gatheredCharges.clear( );

  gatheredPoints.reserve(combinedArrayLength / 3);
  gatheredNormals.reserve(combinedArrayLength / 3);
  gatheredCharges.reserve(combinedArrayLength / 3);

  for (int index = 0; index < combinedArrayLength; index += 3) {
    gatheredPoints.emplace_back(combinedPointArray[index + 0],
				combinedPointArray[index + 1],
				combinedPointArray[index + 2]);

    gatheredNormals.emplace_back(combinedNormalArray[index + 0],
				 combinedNormalArray[index + 1],
				 combinedNormalArray[index + 2]);

    gatheredCharges.emplace_back(combinedChargeArray[index + 0],
				 combinedChargeArray[index + 1],
				 combinedChargeArray[index + 2]);
  }

  delete [] arrayLengths;

  delete [] combinedPointArray;
  delete [] combinedNormalArray;
  delete [] combinedChargeArray;

  delete [] combinedArrayOffsets;

  delete [] pointArray;
  delete [] normalArray;
  delete [] chargeArray;
#endif

  hitPointsGathered = true;
}

void 
ResultsZeno::
updateVariance(int threadNum,
	       double hitMissData,
	       Vector3<double> const & KPlusData, 
	       Vector3<double> const & KMinusData,
	       Matrix3x3<double> const & VPlusData, 
	       Matrix3x3<double> const & VMinusData) {

  updateItemVariance(hitMissData,
		     numWalks[threadNum],
		     &(hitMissMean[threadNum]),
		     &(hitMissM2[threadNum]));

  updateItemVariance(KPlusData,
		     numWalks[threadNum],
		     &(KPlusMean[threadNum]),
		     &(KPlusM2[threadNum]));

  updateItemVariance(KMinusData,
		     numWalks[threadNum],
		     &(KMinusMean[threadNum]),
		     &(KMinusM2[threadNum]));

  updateItemVariance(VPlusData,
		     numWalks[threadNum],
		     &(VPlusMean[threadNum]),
		     &(VPlusM2[threadNum]));

  updateItemVariance(VMinusData,
		     numWalks[threadNum],
		     &(VMinusMean[threadNum]),
		     &(VMinusM2[threadNum]));
}

double 
ResultsZeno::
getNumWalks() const {
  assert(reduced);

  return numWalksReduced;
}

Uncertain<double> 
ResultsZeno::
getNumHits() const {
  assert(reduced);

  return Uncertain<double>(numHitsReduced, numHitsVarianceReduced);
}

Vector3<Uncertain<double> > 
ResultsZeno::
getKPlus() const {
  assert(reduced);

  return Uncertain<double>::zip(KPlusReduced, KPlusVarianceReduced);
}

Vector3<Uncertain<double> > 
ResultsZeno::
getKMinus() const {
  assert(reduced);

  return Uncertain<double>::zip(KMinusReduced, KMinusVarianceReduced);
}

Matrix3x3<Uncertain<double> > 
ResultsZeno::
getVPlus() const {
  assert(reduced);

  return Uncertain<double>::zip(VPlusReduced, VPlusVarianceReduced);
}

Matrix3x3<Uncertain<double> > 
ResultsZeno::
getVMinus() const {
  assert(reduced);

  return Uncertain<double>::zip(VMinusReduced, VMinusVarianceReduced);
}

bool
ResultsZeno::
getSaveHitPoints() const {

  return saveHitPoints;
}

std::vector<Vector3<double> > const * 
ResultsZeno::
getPoints() const {
  assert(saveHitPoints);
  assert(hitPointsGathered);

  return &gatheredPoints;
}

std::vector<Vector3<double> > const * 
ResultsZeno:: 
getNormals() const {
  assert(saveHitPoints);
  assert(hitPointsGathered);

  return &gatheredNormals;
}

std::vector<Vector3<char> > const * 
ResultsZeno:: 
getCharges() const {
  assert(saveHitPoints);
  assert(hitPointsGathered);

  return &gatheredCharges;
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// mode: c++
// End:

// *** END *** ResultsZeno.cc ***

// *** START *** RandomNumber/Rand.cc ***
/// ================================================================
/// 
/// Disclaimer:  IMPORTANT:  This software was developed at the
/// National Institute of Standards and Technology by employees of the
/// Federal Government in the course of their official duties.
/// Pursuant to title 17 Section 105 of the United States Code this
/// software is not subject to copyright protection and is in the
/// public domain.  This is an experimental system.  NIST assumes no
/// responsibility whatsoever for its use by other parties, and makes
/// no guarantees, expressed or implied, about its quality,
/// reliability, or any other characteristic.  We would appreciate
/// acknowledgement if the software is used.  This software can be
/// redistributed and/or modified freely provided that any derivative
/// works bear some notice that they are derived from it, and any
/// modified versions bear some notice that they have been modified.
/// 
/// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Mon Dec 29 11:44:20 2014 EDT
//
// Time-stamp: <2015-05-18 14:40:19 derekj>
//
// ================================================================

// inlined #include "Rand.h"

#include <cstdlib>

// ================================================================

Rand::Rand(int streamNum, int numStreams, int seed) {
  srand(seed);
}

Rand::~Rand() {

}

double 
Rand::getRandIn01() {
  return (rand() / (double)RAND_MAX);
}

double 
Rand::getRandInRange(double min, double max) {
  return (rand() / (double)RAND_MAX) * (max - min) + min;
}

// Local Variables:
// time-stamp-line-limit: 30
// mode: c++
// End:

// *** END *** RandomNumber/Rand.cc ***

// *** START *** SphereCenterModel/NanoFLANNSort.cc ***
// ================================================================
// 
// Disclaimer:  IMPORTANT:  This software was developed at the
// National Institute of Standards and Technology by employees of the
// Federal Government in the course of their official duties.
// Pursuant to title 17 Section 105 of the United States Code this
// software is not subject to copyright protection and is in the
// public domain.  This is an experimental system.  NIST assumes no
// responsibility whatsoever for its use by other parties, and makes
// no guarantees, expressed or implied, about its quality,
// reliability, or any other characteristic.  We would appreciate
// acknowledgement if the software is used.  This software can be
// redistributed and/or modified freely provided that any derivative
// works bear some notice that they are derived from it, and any
// modified versions bear some notice that they have been modified.
// 
// ================================================================

// ================================================================
// 
// Authors: Derek Juba <derek.juba@nist.gov>
// Date:    Fri Aug 15 14:35:07 2014 EDT
//
// Time-stamp: <2016-09-20 17:01:57 dcj>
//
// ================================================================

#include <limits>
#include <cassert>
#include <iostream>

// inlined #include "NanoFLANNSort.h"

// ================================================================

/// Constructs an empty spatial data structure.
///
NanoFLANNSort::NanoFLANNSort()
  : originalSpheres(NULL),
    nanoFLANNInstances() {

}

NanoFLANNSort::~NanoFLANNSort() {
  for (unsigned int i = 0; i < nanoFLANNInstances.size(); i ++) {
    delete nanoFLANNInstances.at(i).dataset;

    delete nanoFLANNInstances.at(i).kdTree;

    delete [] nanoFLANNInstances.at(i).originalSphereIndexes;
  }
}

/// Inserts the given spheres into the spatial data structure, allowing for
/// the given relative error in distance.
///
void 
NanoFLANNSort::preprocess(std::vector<Sphere<double> > const & spheres,
			  double fracErrorBound) {

  originalSpheres = &spheres;

  //count number of spheres of each radius
  for (unsigned int sphereNum = 0; 
       sphereNum < spheres.size(); 
       sphereNum ++) {

    double sphereRadiusSqr = spheres.at(sphereNum).getRadiusSqr();

    bool radiusFound = false;

    for (unsigned int radiusNum = 0; 
	 radiusNum < nanoFLANNInstances.size(); 
	 radiusNum ++) {

      if (nanoFLANNInstances.at(radiusNum).sphereRadiusSqr == sphereRadiusSqr) {
	radiusFound = true;

	nanoFLANNInstances.at(radiusNum).nPts ++;

	break;
      }
    }

    if (!radiusFound) {
      NanoFLANNInstance nanoFLANNInstance;

      nanoFLANNInstance.sphereRadiusSqr = sphereRadiusSqr;
    
      nanoFLANNInstance.nPts = 1;

      nanoFLANNInstance.dataset = NULL;
      nanoFLANNInstance.kdTree  = NULL;

      nanoFLANNInstance.originalSphereIndexes = NULL;

      nanoFLANNInstances.push_back(nanoFLANNInstance);
    }
  }

  //allocate memory for points
  for (unsigned int radiusNum = 0; 
       radiusNum < nanoFLANNInstances.size(); 
       radiusNum ++) {

    int nPts = nanoFLANNInstances.at(radiusNum).nPts;

    nanoFLANNInstances.at(radiusNum).nPts = 0; //reset point counter

    nanoFLANNInstances.at(radiusNum).originalSphereIndexes = new int[nPts];
  }

  //add spheres to instances
  for (unsigned int sphereNum = 0; 
       sphereNum < spheres.size(); 
       sphereNum ++) {

    double sphereRadiusSqr = spheres.at(sphereNum).getRadiusSqr();

    bool radiusFound = false;

    for (unsigned int radiusNum = 0; 
	 radiusNum < nanoFLANNInstances.size(); 
	 radiusNum ++) {

      if (nanoFLANNInstances.at(radiusNum).sphereRadiusSqr == sphereRadiusSqr) {
	radiusFound = true;

	int nPts = nanoFLANNInstances.at(radiusNum).nPts;

	nanoFLANNInstances.at(radiusNum).originalSphereIndexes[nPts] = 
	  sphereNum;

	nanoFLANNInstances.at(radiusNum).nPts ++;

	break;
      }
    }

    assert(radiusFound);
  }

  //build kdTrees
  for (unsigned int radiusNum = 0; 
       radiusNum < nanoFLANNInstances.size(); 
       radiusNum ++) {

    int nPts = nanoFLANNInstances.at(radiusNum).nPts;

    int * originalSphereIndexes = 
      nanoFLANNInstances.at(radiusNum).originalSphereIndexes;

    DatasetAdaptorType * dataset = 
      new DatasetAdaptorType(nPts, originalSphereIndexes, originalSpheres);

    nanoFLANNInstances.at(radiusNum).dataset = dataset;

    nanoFLANNInstances.at(radiusNum).kdTree = new KDTreeType(3, *dataset);

    nanoFLANNInstances.at(radiusNum).kdTree->buildIndex();
  }
}

void 
NanoFLANNSort::printDataStructureStats() 
  const {

  zeno_cxx_fout->ofs << "Number of NanoFLANN instances: " << nanoFLANNInstances.size()
	    << std::endl
	    << "Used memory (MB)" << std::endl;

  for (unsigned int radiusNum = 0; 
       radiusNum < nanoFLANNInstances.size(); 
       radiusNum ++) {

    zeno_cxx_fout->ofs << radiusNum << ": " 
	      << nanoFLANNInstances.at(radiusNum).kdTree->usedMemory() / 1000000.
	      << std::endl;
  }

  zeno_cxx_fout->ofs << std::endl;
}

void 
NanoFLANNSort::printSearchStats() 
  const {

}

/// Return the number of unique sphere radii in the spatial data structure.
///
unsigned int 
NanoFLANNSort::
getNumRadii() 
  const {

  return nanoFLANNInstances.size();
}

/// Searches the spheres in the given radius bin for the closest to the given
/// query point, allowing for the given relative error in distance.  Computes
/// both the closest sphere and the square distance to its center.
///
void 
NanoFLANNSort::
findNearestSphere(int radiusNum,
		  Vector3<double> const & queryPoint,
		  double fracErrorBound,
		  Sphere<double> const * * nearestSphere, 
		  double * centerDistSqr) 
  const {

  double query[3];

  for (int i = 0; i < 3; i++) {
    query[i] = queryPoint.get(i);
  }

  int resultIndex = -1;

  // nanoFLANNInstances.at(radiusNum).kdTree->knnSearch(query, 1, 
  // 						&resultIndex, &distSqr);

  nanoflann::SearchParams params;
  params.eps = fracErrorBound;

  nanoflann::KNNResultSet<double, int> resultSet(1);
  resultSet.init(&resultIndex, centerDistSqr);

  nanoFLANNInstances.at(radiusNum).kdTree->findNeighbors(resultSet, query, 
						     params);

  int sphereIndex = 
    nanoFLANNInstances.at(radiusNum).originalSphereIndexes[resultIndex];

  *nearestSphere = &(originalSpheres->at(sphereIndex));
}

// ================================================================

// Local Variables:
// time-stamp-line-limit: 30
// End:

// *** END *** SphereCenterModel/NanoFLANNSort.cc ***

// *** START *** cmdline.c ***
/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  gengetopt --file-name=cmdline 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
// inlined #include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

// inlined #include "cmdline.h"

const char *gengetopt_args_info_purpose = "";

const char *gengetopt_args_info_usage = "Usage: zeno [OPTIONS]...";

const char *gengetopt_args_info_versiontext = "";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_full_help[] = {
  "  -h, --help                    Print help and exit",
  "      --full-help               Print help, including hidden options, and exit",
  "  -V, --version                 Print version and exit",
  "  -i, --input-file=STRING       Input file name",
  "      --num-walks=LONGLONG      Number of walk-on-spheres walks to perform",
  "      --num-interior-samples=LONGLONG\n                                Number of interior samples to take",
  "      --max-rsd-capacitance=DOUBLE\n                                Perform walk-on-spheres walks until the\n                                  relative standard deviation of the\n                                  capacitance drops below this value.  Relative\n                                  standard deviation is defined as\n                                  (Standard_Deviation/Mean)*100%",
  "      --max-rsd-polarizability=DOUBLE\n                                Perform walk-on-spheres walks until the\n                                  relative standard deviation of the mean\n                                  electric polarizability drops below this\n                                  value.  Relative standard deviation is\n                                  defined as (Standard_Deviation/Mean)*100%",
  "      --max-rsd-volume=DOUBLE   Take interior samples until the relative\n                                  standard deviation of volume drops below this\n                                  value.  Relative standard deviation is\n                                  defined as (Standard_Deviation/Mean)*100%",
  "      --min-num-walks=LONGLONG  Minimum number of walk-on-spheres walks to\n                                  perform when using max-rsd stopping\n                                  conditions  (default=`1000')",
  "      --min-num-interior-samples=LONGLONG\n                                Minimum number of interior samples to take when\n                                  using max-rsd stopping conditions\n                                  (default=`10000')",
  "      --compute-form            Compute form factor",
  "      --num-threads=INT         Number of threads to use  (default=Number of\n                                  logical cores)",
  "      --seed=INT                Seed for the random number generator\n                                  (default=Randomly set)",
  "      --frac-error-bound=DOUBLE Fractional error bound for nearest neighbor\n                                  search  (default=`0')",
  "      --surface-points-file=STRING\n                                Name of file for writing the surface points\n                                  from Walk-on-Spheres",
  "      --interior-points-file=STRING\n                                Name of file for writing the interior sample\n                                  points",
  "      --print-counts            Print statistics related to counts of hit\n                                  points",
  "      --print-benchmarks        Print detailed RAM and timing information",
    0
};

static void
init_help_array(void)
{
  gengetopt_args_info_help[0] = gengetopt_args_info_full_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_full_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_full_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_full_help[3];
  gengetopt_args_info_help[4] = gengetopt_args_info_full_help[4];
  gengetopt_args_info_help[5] = gengetopt_args_info_full_help[5];
  gengetopt_args_info_help[6] = gengetopt_args_info_full_help[6];
  gengetopt_args_info_help[7] = gengetopt_args_info_full_help[7];
  gengetopt_args_info_help[8] = gengetopt_args_info_full_help[8];
  gengetopt_args_info_help[9] = gengetopt_args_info_full_help[9];
  gengetopt_args_info_help[10] = gengetopt_args_info_full_help[10];
  gengetopt_args_info_help[11] = gengetopt_args_info_full_help[11];
  gengetopt_args_info_help[12] = gengetopt_args_info_full_help[12];
  gengetopt_args_info_help[13] = gengetopt_args_info_full_help[13];
  gengetopt_args_info_help[14] = gengetopt_args_info_full_help[15];
  gengetopt_args_info_help[15] = gengetopt_args_info_full_help[16];
  gengetopt_args_info_help[16] = gengetopt_args_info_full_help[17];
  gengetopt_args_info_help[17] = gengetopt_args_info_full_help[18];
  gengetopt_args_info_help[18] = 0; 
  
}

const char *gengetopt_args_info_help[19];

typedef enum {ARG_NO
  , ARG_STRING
  , ARG_INT
  , ARG_DOUBLE
  , ARG_LONGLONG
} cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error);

static int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->input_file_given = 0 ;
  args_info->num_walks_given = 0 ;
  args_info->num_interior_samples_given = 0 ;
  args_info->max_rsd_capacitance_given = 0 ;
  args_info->max_rsd_polarizability_given = 0 ;
  args_info->max_rsd_volume_given = 0 ;
  args_info->min_num_walks_given = 0 ;
  args_info->min_num_interior_samples_given = 0 ;
  args_info->compute_form_given = 0 ;
  args_info->num_threads_given = 0 ;
  args_info->seed_given = 0 ;
  args_info->frac_error_bound_given = 0 ;
  args_info->surface_points_file_given = 0 ;
  args_info->interior_points_file_given = 0 ;
  args_info->print_counts_given = 0 ;
  args_info->print_benchmarks_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->input_file_arg = NULL;
  args_info->input_file_orig = NULL;
  args_info->num_walks_orig = NULL;
  args_info->num_interior_samples_orig = NULL;
  args_info->max_rsd_capacitance_orig = NULL;
  args_info->max_rsd_polarizability_orig = NULL;
  args_info->max_rsd_volume_orig = NULL;
  args_info->min_num_walks_arg = 1000;
  args_info->min_num_walks_orig = NULL;
  args_info->min_num_interior_samples_arg = 10000;
  args_info->min_num_interior_samples_orig = NULL;
  args_info->num_threads_orig = NULL;
  args_info->seed_orig = NULL;
  args_info->frac_error_bound_arg = 0;
  args_info->frac_error_bound_orig = NULL;
  args_info->surface_points_file_arg = NULL;
  args_info->surface_points_file_orig = NULL;
  args_info->interior_points_file_arg = NULL;
  args_info->interior_points_file_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{

  init_help_array(); 
  args_info->help_help = gengetopt_args_info_full_help[0] ;
  args_info->full_help_help = gengetopt_args_info_full_help[1] ;
  args_info->version_help = gengetopt_args_info_full_help[2] ;
  args_info->input_file_help = gengetopt_args_info_full_help[3] ;
  args_info->num_walks_help = gengetopt_args_info_full_help[4] ;
  args_info->num_interior_samples_help = gengetopt_args_info_full_help[5] ;
  args_info->max_rsd_capacitance_help = gengetopt_args_info_full_help[6] ;
  args_info->max_rsd_polarizability_help = gengetopt_args_info_full_help[7] ;
  args_info->max_rsd_volume_help = gengetopt_args_info_full_help[8] ;
  args_info->min_num_walks_help = gengetopt_args_info_full_help[9] ;
  args_info->min_num_interior_samples_help = gengetopt_args_info_full_help[10] ;
  args_info->compute_form_help = gengetopt_args_info_full_help[11] ;
  args_info->num_threads_help = gengetopt_args_info_full_help[12] ;
  args_info->seed_help = gengetopt_args_info_full_help[13] ;
  args_info->frac_error_bound_help = gengetopt_args_info_full_help[14] ;
  args_info->surface_points_file_help = gengetopt_args_info_full_help[15] ;
  args_info->interior_points_file_help = gengetopt_args_info_full_help[16] ;
  args_info->print_counts_help = gengetopt_args_info_full_help[17] ;
  args_info->print_benchmarks_help = gengetopt_args_info_full_help[18] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(CMDLINE_PARSER_PACKAGE_NAME) ? CMDLINE_PARSER_PACKAGE_NAME : CMDLINE_PARSER_PACKAGE),
     CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_print_full_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);
}

void
cmdline_parser_params_init(struct cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct cmdline_parser_params *
cmdline_parser_params_create(void)
{
  struct cmdline_parser_params *params = 
    (struct cmdline_parser_params *)malloc(sizeof(struct cmdline_parser_params));
  cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{

  free_string_field (&(args_info->input_file_arg));
  free_string_field (&(args_info->input_file_orig));
  free_string_field (&(args_info->num_walks_orig));
  free_string_field (&(args_info->num_interior_samples_orig));
  free_string_field (&(args_info->max_rsd_capacitance_orig));
  free_string_field (&(args_info->max_rsd_polarizability_orig));
  free_string_field (&(args_info->max_rsd_volume_orig));
  free_string_field (&(args_info->min_num_walks_orig));
  free_string_field (&(args_info->min_num_interior_samples_orig));
  free_string_field (&(args_info->num_threads_orig));
  free_string_field (&(args_info->seed_orig));
  free_string_field (&(args_info->frac_error_bound_orig));
  free_string_field (&(args_info->surface_points_file_arg));
  free_string_field (&(args_info->surface_points_file_orig));
  free_string_field (&(args_info->interior_points_file_arg));
  free_string_field (&(args_info->interior_points_file_orig));
  
  

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->input_file_given)
    write_into_file(outfile, "input-file", args_info->input_file_orig, 0);
  if (args_info->num_walks_given)
    write_into_file(outfile, "num-walks", args_info->num_walks_orig, 0);
  if (args_info->num_interior_samples_given)
    write_into_file(outfile, "num-interior-samples", args_info->num_interior_samples_orig, 0);
  if (args_info->max_rsd_capacitance_given)
    write_into_file(outfile, "max-rsd-capacitance", args_info->max_rsd_capacitance_orig, 0);
  if (args_info->max_rsd_polarizability_given)
    write_into_file(outfile, "max-rsd-polarizability", args_info->max_rsd_polarizability_orig, 0);
  if (args_info->max_rsd_volume_given)
    write_into_file(outfile, "max-rsd-volume", args_info->max_rsd_volume_orig, 0);
  if (args_info->min_num_walks_given)
    write_into_file(outfile, "min-num-walks", args_info->min_num_walks_orig, 0);
  if (args_info->min_num_interior_samples_given)
    write_into_file(outfile, "min-num-interior-samples", args_info->min_num_interior_samples_orig, 0);
  if (args_info->compute_form_given)
    write_into_file(outfile, "compute-form", 0, 0 );
  if (args_info->num_threads_given)
    write_into_file(outfile, "num-threads", args_info->num_threads_orig, 0);
  if (args_info->seed_given)
    write_into_file(outfile, "seed", args_info->seed_orig, 0);
  if (args_info->frac_error_bound_given)
    write_into_file(outfile, "frac-error-bound", args_info->frac_error_bound_orig, 0);
  if (args_info->surface_points_file_given)
    write_into_file(outfile, "surface-points-file", args_info->surface_points_file_orig, 0);
  if (args_info->interior_points_file_given)
    write_into_file(outfile, "interior-points-file", args_info->interior_points_file_orig, 0);
  if (args_info->print_counts_given)
    write_into_file(outfile, "print-counts", 0, 0 );
  if (args_info->print_benchmarks_given)
    write_into_file(outfile, "print-benchmarks", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = us_fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct cmdline_parser_params *params)
{
  int result;
  result = cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (! args_info->input_file_given)
    {
      fprintf (stderr, "%s: '--input-file' ('-i') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  
  
  /* checks for dependences among options */

  return error_occurred;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see cmdline_parser_params.check_ambiguity
 * @param override @see cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_DOUBLE:
    if (val) *((double *)field) = strtod (val, &stop_char);
    break;
  case ARG_LONGLONG:
#if defined(HAVE_LONG_LONG) || defined(HAVE_LONG_LONG_INT)
    if (val) *((long long int*)field) = (long long int) strtoll (val, &stop_char, 0);
#else
    if (val) *((long *)field) = (long)strtol (val, &stop_char, 0);
#endif
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_DOUBLE:
  case ARG_LONGLONG:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "full-help",	0, NULL, 0 },
        { "version",	0, NULL, 'V' },
        { "input-file",	1, NULL, 'i' },
        { "num-walks",	1, NULL, 0 },
        { "num-interior-samples",	1, NULL, 0 },
        { "max-rsd-capacitance",	1, NULL, 0 },
        { "max-rsd-polarizability",	1, NULL, 0 },
        { "max-rsd-volume",	1, NULL, 0 },
        { "min-num-walks",	1, NULL, 0 },
        { "min-num-interior-samples",	1, NULL, 0 },
        { "compute-form",	0, NULL, 0 },
        { "num-threads",	1, NULL, 0 },
        { "seed",	1, NULL, 0 },
        { "frac-error-bound",	1, NULL, 0 },
        { "surface-points-file",	1, NULL, 0 },
        { "interior-points-file",	1, NULL, 0 },
        { "print-counts",	0, NULL, 0 },
        { "print-benchmarks",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "hVi:", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'i':	/* Input file name.  */
        
        
          if (update_arg( (void *)&(args_info->input_file_arg), 
               &(args_info->input_file_orig), &(args_info->input_file_given),
              &(local_args_info.input_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "input-file", 'i',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          if (strcmp (long_options[option_index].name, "full-help") == 0) {
            cmdline_parser_print_full_help ();
            cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

          /* Number of walk-on-spheres walks to perform.  */
          if (strcmp (long_options[option_index].name, "num-walks") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->num_walks_arg), 
                 &(args_info->num_walks_orig), &(args_info->num_walks_given),
                &(local_args_info.num_walks_given), optarg, 0, 0, ARG_LONGLONG,
                check_ambiguity, override, 0, 0,
                "num-walks", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of interior samples to take.  */
          else if (strcmp (long_options[option_index].name, "num-interior-samples") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->num_interior_samples_arg), 
                 &(args_info->num_interior_samples_orig), &(args_info->num_interior_samples_given),
                &(local_args_info.num_interior_samples_given), optarg, 0, 0, ARG_LONGLONG,
                check_ambiguity, override, 0, 0,
                "num-interior-samples", '-',
                additional_error))
              goto failure;
          
          }
          /* Perform walk-on-spheres walks until the relative standard deviation of the capacitance drops below this value.  Relative standard deviation is defined as (Standard_Deviation/Mean)*100%.  */
          else if (strcmp (long_options[option_index].name, "max-rsd-capacitance") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->max_rsd_capacitance_arg), 
                 &(args_info->max_rsd_capacitance_orig), &(args_info->max_rsd_capacitance_given),
                &(local_args_info.max_rsd_capacitance_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "max-rsd-capacitance", '-',
                additional_error))
              goto failure;
          
          }
          /* Perform walk-on-spheres walks until the relative standard deviation of the mean electric polarizability drops below this value.  Relative standard deviation is defined as (Standard_Deviation/Mean)*100%.  */
          else if (strcmp (long_options[option_index].name, "max-rsd-polarizability") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->max_rsd_polarizability_arg), 
                 &(args_info->max_rsd_polarizability_orig), &(args_info->max_rsd_polarizability_given),
                &(local_args_info.max_rsd_polarizability_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "max-rsd-polarizability", '-',
                additional_error))
              goto failure;
          
          }
          /* Take interior samples until the relative standard deviation of volume drops below this value.  Relative standard deviation is defined as (Standard_Deviation/Mean)*100%.  */
          else if (strcmp (long_options[option_index].name, "max-rsd-volume") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->max_rsd_volume_arg), 
                 &(args_info->max_rsd_volume_orig), &(args_info->max_rsd_volume_given),
                &(local_args_info.max_rsd_volume_given), optarg, 0, 0, ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "max-rsd-volume", '-',
                additional_error))
              goto failure;
          
          }
          /* Minimum number of walk-on-spheres walks to perform when using max-rsd stopping conditions.  */
          else if (strcmp (long_options[option_index].name, "min-num-walks") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->min_num_walks_arg), 
                 &(args_info->min_num_walks_orig), &(args_info->min_num_walks_given),
                &(local_args_info.min_num_walks_given), optarg, 0, "1000", ARG_LONGLONG,
                check_ambiguity, override, 0, 0,
                "min-num-walks", '-',
                additional_error))
              goto failure;
          
          }
          /* Minimum number of interior samples to take when using max-rsd stopping conditions.  */
          else if (strcmp (long_options[option_index].name, "min-num-interior-samples") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->min_num_interior_samples_arg), 
                 &(args_info->min_num_interior_samples_orig), &(args_info->min_num_interior_samples_given),
                &(local_args_info.min_num_interior_samples_given), optarg, 0, "10000", ARG_LONGLONG,
                check_ambiguity, override, 0, 0,
                "min-num-interior-samples", '-',
                additional_error))
              goto failure;
          
          }
          /* Compute form factor.  */
          else if (strcmp (long_options[option_index].name, "compute-form") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->compute_form_given),
                &(local_args_info.compute_form_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "compute-form", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of threads to use  (default=Number of logical cores).  */
          else if (strcmp (long_options[option_index].name, "num-threads") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->num_threads_arg), 
                 &(args_info->num_threads_orig), &(args_info->num_threads_given),
                &(local_args_info.num_threads_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "num-threads", '-',
                additional_error))
              goto failure;
          
          }
          /* Seed for the random number generator  (default=Randomly set).  */
          else if (strcmp (long_options[option_index].name, "seed") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->seed_arg), 
                 &(args_info->seed_orig), &(args_info->seed_given),
                &(local_args_info.seed_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "seed", '-',
                additional_error))
              goto failure;
          
          }
          /* Fractional error bound for nearest neighbor search.  */
          else if (strcmp (long_options[option_index].name, "frac-error-bound") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->frac_error_bound_arg), 
                 &(args_info->frac_error_bound_orig), &(args_info->frac_error_bound_given),
                &(local_args_info.frac_error_bound_given), optarg, 0, "0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "frac-error-bound", '-',
                additional_error))
              goto failure;
          
          }
          /* Name of file for writing the surface points from Walk-on-Spheres.  */
          else if (strcmp (long_options[option_index].name, "surface-points-file") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->surface_points_file_arg), 
                 &(args_info->surface_points_file_orig), &(args_info->surface_points_file_given),
                &(local_args_info.surface_points_file_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "surface-points-file", '-',
                additional_error))
              goto failure;
          
          }
          /* Name of file for writing the interior sample points.  */
          else if (strcmp (long_options[option_index].name, "interior-points-file") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->interior_points_file_arg), 
                 &(args_info->interior_points_file_orig), &(args_info->interior_points_file_given),
                &(local_args_info.interior_points_file_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "interior-points-file", '-',
                additional_error))
              goto failure;
          
          }
          /* Print statistics related to counts of hit points.  */
          else if (strcmp (long_options[option_index].name, "print-counts") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->print_counts_given),
                &(local_args_info.print_counts_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "print-counts", '-',
                additional_error))
              goto failure;
          
          }
          /* Print detailed RAM and timing information.  */
          else if (strcmp (long_options[option_index].name, "print-benchmarks") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->print_benchmarks_given),
                &(local_args_info.print_benchmarks_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "print-benchmarks", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error_occurred += cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}

// *** END *** cmdline.c ***


#endif //  __cplusplus >= 201103L
