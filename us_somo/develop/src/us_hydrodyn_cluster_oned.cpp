#include "../include/us3_defines.h"
#include <QRegularExpression>
// ---------------------------------------------------------------------------------------------
// --------------- WARNING: this code is generated by an automatic code generator --------------
// ---------------------------------------------------------------------------------------------
// -------------- WARNING: any modifications made to this code will be overwritten -------------
// ---------------------------------------------------------------------------------------------

#include "../include/us_hydrodyn_cluster_oned.h"
//Added by qt3to4:
#include <QTextStream>
#include <QHBoxLayout>
#include <QCloseEvent>
#include <QFrame>
#include <QLabel>
#include <QVBoxLayout>

US_Hydrodyn_Cluster_Oned::US_Hydrodyn_Cluster_Oned(
                                                   void                     *              us_hydrodyn,
                                                   map < QString, QString > *              parameters,
                                                   QWidget *                               p,
                                                   const char *                            
                                                   ) : QDialog( p )
{
   this->us_hydrodyn                          = us_hydrodyn;
   this->parameters                           = parameters;

   USglobal = new US_Config();
   setPalette( PALET_FRAME );
   setWindowTitle( us_tr( "US-SOMO: 1d cluster interface" ) );

   setupGUI();

   global_Xpos += 30;
   global_Ypos += 30;

   setGeometry( global_Xpos, global_Ypos, 0, 0 );
}

US_Hydrodyn_Cluster_Oned::~US_Hydrodyn_Cluster_Oned()
{
}

void US_Hydrodyn_Cluster_Oned::setupGUI()
{
   int minHeight1  = 30;

   lbl_title =  new QLabel      ( us_tr( "US-SOMO: 1d cluster interface" ), this );
   lbl_title -> setFrameStyle   ( QFrame::WinPanel | QFrame::Raised );
   lbl_title -> setAlignment    ( Qt::AlignCenter | Qt::AlignVCenter );
   lbl_title -> setMinimumHeight( minHeight1 );
   lbl_title -> setPalette      ( PALET_FRAME );
   AUTFBACK( lbl_title );
   lbl_title -> setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1, QFont::Bold ) );

   lbl_credits_1 =  new QLabel      ( "Brookes.", this );
   lbl_credits_1 -> setAlignment    ( Qt::AlignCenter | Qt::AlignVCenter );
   lbl_credits_1 -> setMinimumHeight( minHeight1 );
   lbl_credits_1 -> setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_credits_1 );
   lbl_credits_1 -> setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize+1, QFont::Bold ) );

   lbl_1drotationfile = new QLabel      ( us_tr( "Rotation file" ), this );
   lbl_1drotationfile ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1drotationfile ->setMinimumHeight( minHeight1 );
   lbl_1drotationfile ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1drotationfile );
   lbl_1drotationfile ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1drotationfile ->setMinimumWidth ( QFontMetrics( lbl_1drotationfile->font() ).maxWidth() * 21 );

   le_1drotationfile = new QLineEdit     (  this );    le_1drotationfile->setObjectName( "1drotationfile Line Edit" );
   if ( !parameters->count( "1drotationfile" ) )
   {
      (*parameters)[ "1drotationfile" ] = "";
   }
   le_1drotationfile ->setText           ( ( *parameters )[ "1drotationfile" ] );
   le_1drotationfile ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1drotationfile ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1drotationfile );
   le_1drotationfile ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1drotationfile ->setMinimumHeight  ( minHeight1 );
   le_1drotationfile ->setMinimumWidth   ( 150 );
   connect( le_1drotationfile, SIGNAL( textChanged( const QString & ) ), SLOT( update_1drotationfile( const QString & ) ) );

   lbl_1drotationsuserand = new QLabel      ( us_tr( "Use drand48() for rotations" ), this );
   lbl_1drotationsuserand ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1drotationsuserand ->setMinimumHeight( minHeight1 );
   lbl_1drotationsuserand ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1drotationsuserand );
   lbl_1drotationsuserand ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1drotationsuserand ->setMinimumWidth ( QFontMetrics( lbl_1drotationsuserand->font() ).maxWidth() * 21 );

   le_1drotationsuserand = new QLineEdit     (  this );    le_1drotationsuserand->setObjectName( "1drotationsuserand Line Edit" );
   le_1drotationsuserand ->setText           ( parameters->count( "1drotationsuserand" ) ? ( *parameters )[ "1drotationsuserand" ] : "" );
   le_1drotationsuserand ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1drotationsuserand ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1drotationsuserand );
   le_1drotationsuserand ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1drotationsuserand ->setMinimumHeight  ( minHeight1 );
   le_1drotationsuserand ->setMinimumWidth   ( 150 );
   connect( le_1drotationsuserand, SIGNAL( textChanged( const QString & ) ), SLOT( update_1drotationsuserand( const QString & ) ) );

   lbl_1dlambda = new QLabel      ( us_tr( "Lambda" ), this );
   lbl_1dlambda ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1dlambda ->setMinimumHeight( minHeight1 );
   lbl_1dlambda ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1dlambda );
   lbl_1dlambda ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1dlambda ->setMinimumWidth ( QFontMetrics( lbl_1dlambda->font() ).maxWidth() * 21 );

   le_1dlambda = new QLineEdit     (  this );    le_1dlambda->setObjectName( "1dlambda Line Edit" );
   if ( !parameters->count( "1dlambda" ) )
   {
      (*parameters)[ "1dlambda" ] = "1.54";
   }
   le_1dlambda ->setText           ( ( *parameters )[ "1dlambda" ] );
   le_1dlambda ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1dlambda ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1dlambda );
   le_1dlambda ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1dlambda ->setMinimumHeight  ( minHeight1 );
   le_1dlambda ->setMinimumWidth   ( 150 );
   connect( le_1dlambda, SIGNAL( textChanged( const QString & ) ), SLOT( update_1dlambda( const QString & ) ) );

   lbl_1ddetectordistance = new QLabel      ( us_tr( "Detector distance (m)" ), this );
   lbl_1ddetectordistance ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1ddetectordistance ->setMinimumHeight( minHeight1 );
   lbl_1ddetectordistance ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1ddetectordistance );
   lbl_1ddetectordistance ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1ddetectordistance ->setMinimumWidth ( QFontMetrics( lbl_1ddetectordistance->font() ).maxWidth() * 21 );

   le_1ddetectordistance = new QLineEdit     (  this );    le_1ddetectordistance->setObjectName( "1ddetectordistance Line Edit" );
   if ( !parameters->count( "1ddetectordistance" ) )
   {
      (*parameters)[ "1ddetectordistance" ] = "1.33";
   }
   le_1ddetectordistance ->setText           ( ( *parameters )[ "1ddetectordistance" ] );
   le_1ddetectordistance ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1ddetectordistance ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1ddetectordistance );
   le_1ddetectordistance ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1ddetectordistance ->setMinimumHeight  ( minHeight1 );
   le_1ddetectordistance ->setMinimumWidth   ( 150 );
   connect( le_1ddetectordistance, SIGNAL( textChanged( const QString & ) ), SLOT( update_1ddetectordistance( const QString & ) ) );

   lbl_1ddetectorwidth = new QLabel      ( us_tr( "Detector width (mm)" ), this );
   lbl_1ddetectorwidth ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1ddetectorwidth ->setMinimumHeight( minHeight1 );
   lbl_1ddetectorwidth ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1ddetectorwidth );
   lbl_1ddetectorwidth ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1ddetectorwidth ->setMinimumWidth ( QFontMetrics( lbl_1ddetectorwidth->font() ).maxWidth() * 21 );

   le_1ddetectorwidth = new QLineEdit     (  this );    le_1ddetectorwidth->setObjectName( "1ddetectorwidth Line Edit" );
   if ( !parameters->count( "1ddetectorwidth" ) )
   {
      (*parameters)[ "1ddetectorwidth" ] = "341";
   }
   le_1ddetectorwidth ->setText           ( ( *parameters )[ "1ddetectorwidth" ] );
   le_1ddetectorwidth ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1ddetectorwidth ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1ddetectorwidth );
   le_1ddetectorwidth ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1ddetectorwidth ->setMinimumHeight  ( minHeight1 );
   le_1ddetectorwidth ->setMinimumWidth   ( 150 );
   connect( le_1ddetectorwidth, SIGNAL( textChanged( const QString & ) ), SLOT( update_1ddetectorwidth( const QString & ) ) );

   lbl_1ddetectorpixelswidth = new QLabel      ( us_tr( "Detector pixels width" ), this );
   lbl_1ddetectorpixelswidth ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1ddetectorpixelswidth ->setMinimumHeight( minHeight1 );
   lbl_1ddetectorpixelswidth ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1ddetectorpixelswidth );
   lbl_1ddetectorpixelswidth ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1ddetectorpixelswidth ->setMinimumWidth ( QFontMetrics( lbl_1ddetectorpixelswidth->font() ).maxWidth() * 21 );

   le_1ddetectorpixelswidth = new QLineEdit     (  this );    le_1ddetectorpixelswidth->setObjectName( "1ddetectorpixelswidth Line Edit" );
   if ( !parameters->count( "1ddetectorpixelswidth" ) )
   {
      (*parameters)[ "1ddetectorpixelswidth" ] = "50";
   }
   le_1ddetectorpixelswidth ->setText           ( ( *parameters )[ "1ddetectorpixelswidth" ] );
   le_1ddetectorpixelswidth ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1ddetectorpixelswidth ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1ddetectorpixelswidth );
   le_1ddetectorpixelswidth ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1ddetectorpixelswidth ->setMinimumHeight  ( minHeight1 );
   le_1ddetectorpixelswidth ->setMinimumWidth   ( 150 );
   connect( le_1ddetectorpixelswidth, SIGNAL( textChanged( const QString & ) ), SLOT( update_1ddetectorpixelswidth( const QString & ) ) );

   lbl_1drho0 = new QLabel      ( us_tr( "Solvent electron density: rho0 (e-/A^3)" ), this );
   lbl_1drho0 ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1drho0 ->setMinimumHeight( minHeight1 );
   lbl_1drho0 ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1drho0 );
   lbl_1drho0 ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1drho0 ->setMinimumWidth ( QFontMetrics( lbl_1drho0->font() ).maxWidth() * 21 );

   le_1drho0 = new QLineEdit     (  this );    le_1drho0->setObjectName( "1drho0 Line Edit" );
   if ( !parameters->count( "1drho0" ) )
   {
      (*parameters)[ "1drho0" ] = "0";
   }
   le_1drho0 ->setText           ( ( *parameters )[ "1drho0" ] );
   le_1drho0 ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1drho0 ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1drho0 );
   le_1drho0 ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1drho0 ->setMinimumHeight  ( minHeight1 );
   le_1drho0 ->setMinimumWidth   ( 150 );
   connect( le_1drho0, SIGNAL( textChanged( const QString & ) ), SLOT( update_1drho0( const QString & ) ) );

   lbl_1ddeltar = new QLabel      ( us_tr( "Excluded volume: delta R" ), this );
   lbl_1ddeltar ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1ddeltar ->setMinimumHeight( minHeight1 );
   lbl_1ddeltar ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1ddeltar );
   lbl_1ddeltar ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1ddeltar ->setMinimumWidth ( QFontMetrics( lbl_1ddeltar->font() ).maxWidth() * 21 );

   le_1ddeltar = new QLineEdit     (  this );    le_1ddeltar->setObjectName( "1ddeltar Line Edit" );
   if ( !parameters->count( "1ddeltar" ) )
   {
      (*parameters)[ "1ddeltar" ] = "1";
   }
   le_1ddeltar ->setText           ( ( *parameters )[ "1ddeltar" ] );
   le_1ddeltar ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1ddeltar ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1ddeltar );
   le_1ddeltar ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1ddeltar ->setMinimumHeight  ( minHeight1 );
   le_1ddeltar ->setMinimumWidth   ( 150 );
   connect( le_1ddeltar, SIGNAL( textChanged( const QString & ) ), SLOT( update_1ddeltar( const QString & ) ) );

   lbl_1dproberadius = new QLabel      ( us_tr( "Excluded volume: probe radius" ), this );
   lbl_1dproberadius ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1dproberadius ->setMinimumHeight( minHeight1 );
   lbl_1dproberadius ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1dproberadius );
   lbl_1dproberadius ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1dproberadius ->setMinimumWidth ( QFontMetrics( lbl_1dproberadius->font() ).maxWidth() * 21 );

   le_1dproberadius = new QLineEdit     (  this );    le_1dproberadius->setObjectName( "1dproberadius Line Edit" );
   if ( !parameters->count( "1dproberadius" ) )
   {
      (*parameters)[ "1dproberadius" ] = "1.4";
   }
   le_1dproberadius ->setText           ( ( *parameters )[ "1dproberadius" ] );
   le_1dproberadius ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1dproberadius ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1dproberadius );
   le_1dproberadius ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1dproberadius ->setMinimumHeight  ( minHeight1 );
   le_1dproberadius ->setMinimumWidth   ( 150 );
   connect( le_1dproberadius, SIGNAL( textChanged( const QString & ) ), SLOT( update_1dproberadius( const QString & ) ) );

   lbl_1dthreshold = new QLabel      ( us_tr( "Excluded volume: threshold" ), this );
   lbl_1dthreshold ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1dthreshold ->setMinimumHeight( minHeight1 );
   lbl_1dthreshold ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1dthreshold );
   lbl_1dthreshold ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1dthreshold ->setMinimumWidth ( QFontMetrics( lbl_1dthreshold->font() ).maxWidth() * 21 );

   le_1dthreshold = new QLineEdit     (  this );    le_1dthreshold->setObjectName( "1dthreshold Line Edit" );
   if ( !parameters->count( "1dthreshold" ) )
   {
      (*parameters)[ "1dthreshold" ] = "1";
   }
   le_1dthreshold ->setText           ( ( *parameters )[ "1dthreshold" ] );
   le_1dthreshold ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1dthreshold ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1dthreshold );
   le_1dthreshold ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1dthreshold ->setMinimumHeight  ( minHeight1 );
   le_1dthreshold ->setMinimumWidth   ( 150 );
   connect( le_1dthreshold, SIGNAL( textChanged( const QString & ) ), SLOT( update_1dthreshold( const QString & ) ) );

   lbl_1dsamplerotations = new QLabel      ( us_tr( "Sample rotations" ), this );
   lbl_1dsamplerotations ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1dsamplerotations ->setMinimumHeight( minHeight1 );
   lbl_1dsamplerotations ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1dsamplerotations );
   lbl_1dsamplerotations ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1dsamplerotations ->setMinimumWidth ( QFontMetrics( lbl_1dsamplerotations->font() ).maxWidth() * 21 );

   le_1dsamplerotations = new QLineEdit     (  this );    le_1dsamplerotations->setObjectName( "1dsamplerotations Line Edit" );
   if ( !parameters->count( "1dsamplerotations" ) )
   {
      (*parameters)[ "1dsamplerotations" ] = "1";
   }
   le_1dsamplerotations ->setText           ( ( *parameters )[ "1dsamplerotations" ] );
   le_1dsamplerotations ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1dsamplerotations ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1dsamplerotations );
   le_1dsamplerotations ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1dsamplerotations ->setMinimumHeight  ( minHeight1 );
   le_1dsamplerotations ->setMinimumWidth   ( 150 );
   connect( le_1dsamplerotations, SIGNAL( textChanged( const QString & ) ), SLOT( update_1dsamplerotations( const QString & ) ) );

   lbl_1daxisrotations = new QLabel      ( us_tr( "Axis rotations" ), this );
   lbl_1daxisrotations ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1daxisrotations ->setMinimumHeight( minHeight1 );
   lbl_1daxisrotations ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1daxisrotations );
   lbl_1daxisrotations ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1daxisrotations ->setMinimumWidth ( QFontMetrics( lbl_1daxisrotations->font() ).maxWidth() * 21 );

   le_1daxisrotations = new QLineEdit     (  this );    le_1daxisrotations->setObjectName( "1daxisrotations Line Edit" );
   if ( !parameters->count( "1daxisrotations" ) )
   {
      (*parameters)[ "1daxisrotations" ] = "1";
   }
   le_1daxisrotations ->setText           ( ( *parameters )[ "1daxisrotations" ] );
   le_1daxisrotations ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1daxisrotations ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1daxisrotations );
   le_1daxisrotations ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1daxisrotations ->setMinimumHeight  ( minHeight1 );
   le_1daxisrotations ->setMinimumWidth   ( 150 );
   connect( le_1daxisrotations, SIGNAL( textChanged( const QString & ) ), SLOT( update_1daxisrotations( const QString & ) ) );

   lbl_1dintermediatesaves = new QLabel      ( us_tr( "Intermediate saves (comma separated)" ), this );
   lbl_1dintermediatesaves ->setAlignment    ( Qt::AlignLeft | Qt::AlignVCenter );
   lbl_1dintermediatesaves ->setMinimumHeight( minHeight1 );
   lbl_1dintermediatesaves ->setPalette      ( PALET_LABEL );
   AUTFBACK( lbl_1dintermediatesaves );
   lbl_1dintermediatesaves ->setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize-1, QFont::Bold ) );
   lbl_1dintermediatesaves ->setMinimumWidth ( QFontMetrics( lbl_1dintermediatesaves->font() ).maxWidth() * 21 );

   le_1dintermediatesaves = new QLineEdit     (  this );    le_1dintermediatesaves->setObjectName( "1dintermediatesaves Line Edit" );
   le_1dintermediatesaves ->setText           ( parameters->count( "1dintermediatesaves" ) ? ( *parameters )[ "1dintermediatesaves" ] : "" );
   le_1dintermediatesaves ->setAlignment      ( Qt::AlignCenter | Qt::AlignVCenter );
   le_1dintermediatesaves ->setPalette        ( PALET_NORMAL );
   AUTFBACK( le_1dintermediatesaves );
   le_1dintermediatesaves ->setFont           ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize));
   le_1dintermediatesaves ->setMinimumHeight  ( minHeight1 );
   le_1dintermediatesaves ->setMinimumWidth   ( 150 );
   connect( le_1dintermediatesaves, SIGNAL( textChanged( const QString & ) ), SLOT( update_1dintermediatesaves( const QString & ) ) );

   pb_save =  new QPushButton ( us_tr( "Save" ), this );
   pb_save -> setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1) );
   pb_save -> setMinimumHeight( minHeight1 );
   pb_save -> setPalette      ( PALET_PUSHB );
   connect( pb_save, SIGNAL( clicked() ), SLOT( save() ) );

   pb_load =  new QPushButton ( us_tr( "Load" ), this );
   pb_load -> setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1) );
   pb_load -> setMinimumHeight( minHeight1 );
   pb_load -> setPalette      ( PALET_PUSHB );
   connect( pb_load, SIGNAL( clicked() ), SLOT( load() ) );

   pb_help =  new QPushButton ( us_tr( "Help" ), this );
   pb_help -> setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1) );
   pb_help -> setMinimumHeight( minHeight1 );
   pb_help -> setPalette      ( PALET_PUSHB );
   connect( pb_help, SIGNAL( clicked() ), SLOT( help() ) );

   pb_close =  new QPushButton ( us_tr( "Close" ), this );
   pb_close -> setFont         ( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1) );
   pb_close -> setMinimumHeight( minHeight1 );
   pb_close -> setPalette      ( PALET_PUSHB );
   connect( pb_close, SIGNAL( clicked() ), SLOT( cancel() ) );

   QVBoxLayout * background = new QVBoxLayout( this ); background->setContentsMargins( 0, 0, 0, 0 ); background->setSpacing( 0 );
   background->addSpacing(4);

   background->addWidget( lbl_title );
   background->addWidget( lbl_credits_1 );
   background->addSpacing( 4 );
   QHBoxLayout * hbl = new QHBoxLayout(); hbl->setContentsMargins( 0, 0, 0, 0 ); hbl->setSpacing( 0 );
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1drotationfile );
   hbl->addWidget( le_1drotationfile );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1drotationsuserand );
   hbl->addWidget( le_1drotationsuserand );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1dlambda );
   hbl->addWidget( le_1dlambda );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1ddetectordistance );
   hbl->addWidget( le_1ddetectordistance );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1ddetectorwidth );
   hbl->addWidget( le_1ddetectorwidth );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1ddetectorpixelswidth );
   hbl->addWidget( le_1ddetectorpixelswidth );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1drho0 );
   hbl->addWidget( le_1drho0 );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1ddeltar );
   hbl->addWidget( le_1ddeltar );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1dproberadius );
   hbl->addWidget( le_1dproberadius );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1dthreshold );
   hbl->addWidget( le_1dthreshold );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1dsamplerotations );
   hbl->addWidget( le_1dsamplerotations );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1daxisrotations );
   hbl->addWidget( le_1daxisrotations );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( lbl_1dintermediatesaves );
   hbl->addWidget( le_1dintermediatesaves );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );
   hbl->addWidget( pb_save );
   hbl->addSpacing( 4 );
   hbl->addWidget( pb_load );
   hbl->addSpacing( 4 );
   background->addLayout( hbl );
   hbl = new QHBoxLayout();
   hbl->addSpacing( 4 );


   QHBoxLayout * hbl_bottom = new QHBoxLayout(); hbl_bottom->setContentsMargins( 0, 0, 0, 0 ); hbl_bottom->setSpacing( 0 );
   hbl_bottom->addSpacing( 4 );
   hbl_bottom->addWidget ( pb_help );
   hbl_bottom->addSpacing( 4 );
   hbl_bottom->addWidget ( pb_close );
   hbl_bottom->addSpacing( 4 );

   background->addLayout ( hbl_bottom );
   background->addSpacing( 4 );
   qApp->processEvents();
   resize( 0, 0 );
}

void US_Hydrodyn_Cluster_Oned::cancel()
{
   close();
}

void US_Hydrodyn_Cluster_Oned::help()
{
   US_Help *online_help;
   online_help = new US_Help( this );
   online_help->show_help("manual/somo/oned.html");
}

void US_Hydrodyn_Cluster_Oned::closeEvent( QCloseEvent *e )
{
   if ( parameters->count( "1drotationsuserand" ) &&
        (*parameters)[ "1drotationsuserand" ].isEmpty() )
   {
      parameters->erase( "1drotationsuserand" );
   }
   if ( parameters->count( "1dintermediatesaves" ) &&
        (*parameters)[ "1dintermediatesaves" ].isEmpty() )
   {
      parameters->erase( "1dintermediatesaves" );
   }

   global_Xpos -= 30;
   global_Ypos -= 30;
   e->accept();
}

void US_Hydrodyn_Cluster_Oned::update_1drotationfile( const QString & )
{
   QString use_dir;
   ((US_Hydrodyn *)us_hydrodyn)->select_from_directory_history( use_dir, this );
   QString filename = QFileDialog::getOpenFileName( this , us_tr( "Select a file for Rotation file" ) , use_dir , QString() );


   disconnect( le_1drotationfile, SIGNAL( textChanged( const QString & ) ), 0, 0 );
   le_1drotationfile->setText( filename );
   connect( le_1drotationfile, SIGNAL( textChanged( const QString & ) ), SLOT( update_1drotationfile( const QString & ) ) );
   if ( !filename.isEmpty() )
   {
      ((US_Hydrodyn *)us_hydrodyn)->add_to_directory_history( filename );
   }
   ( *parameters )[ "1drotationfile" ] = le_1drotationfile->text();
}

void US_Hydrodyn_Cluster_Oned::update_1drotationsuserand( const QString & )
{
   ( *parameters )[ "1drotationsuserand" ] = le_1drotationsuserand->text();
}

void US_Hydrodyn_Cluster_Oned::update_1dlambda( const QString & )
{
   ( *parameters )[ "1dlambda" ] = le_1dlambda->text();
}

void US_Hydrodyn_Cluster_Oned::update_1ddetectordistance( const QString & )
{
   ( *parameters )[ "1ddetectordistance" ] = le_1ddetectordistance->text();
}

void US_Hydrodyn_Cluster_Oned::update_1ddetectorwidth( const QString & )
{
   ( *parameters )[ "1ddetectorwidth" ] = le_1ddetectorwidth->text();
}

void US_Hydrodyn_Cluster_Oned::update_1ddetectorpixelswidth( const QString & )
{
   ( *parameters )[ "1ddetectorpixelswidth" ] = le_1ddetectorpixelswidth->text();
}

void US_Hydrodyn_Cluster_Oned::update_1drho0( const QString & )
{
   ( *parameters )[ "1drho0" ] = le_1drho0->text();
}

void US_Hydrodyn_Cluster_Oned::update_1ddeltar( const QString & )
{
   ( *parameters )[ "1ddeltar" ] = le_1ddeltar->text();
}

void US_Hydrodyn_Cluster_Oned::update_1dproberadius( const QString & )
{
   ( *parameters )[ "1dproberadius" ] = le_1dproberadius->text();
}

void US_Hydrodyn_Cluster_Oned::update_1dthreshold( const QString & )
{
   ( *parameters )[ "1dthreshold" ] = le_1dthreshold->text();
}

void US_Hydrodyn_Cluster_Oned::update_1dsamplerotations( const QString & )
{
   ( *parameters )[ "1dsamplerotations" ] = le_1dsamplerotations->text();
}

void US_Hydrodyn_Cluster_Oned::update_1daxisrotations( const QString & )
{
   ( *parameters )[ "1daxisrotations" ] = le_1daxisrotations->text();
}

void US_Hydrodyn_Cluster_Oned::update_1dintermediatesaves( const QString & )
{
   ( *parameters )[ "1dintermediatesaves" ] = le_1dintermediatesaves->text();
}

void US_Hydrodyn_Cluster_Oned::save()
{
   QString use_dir = ((US_Hydrodyn *)us_hydrodyn)->somo_dir + QDir::separator() + "cluster" + QDir::separator() + "parameters";
   ((US_Hydrodyn *)us_hydrodyn)->select_from_directory_history( use_dir, this, true );
   QString filename = QFileDialog::getSaveFileName( this , us_tr( "Save the parameters" ) , use_dir , "*.cluster_oned" );


   if( !filename.isEmpty() )
   {
      ((US_Hydrodyn *)us_hydrodyn)->add_to_directory_history( filename );
      if ( !filename.contains( QRegularExpression( QStringLiteral( "\\.cluster_oned$" ) ) ) )
      {
         filename += ".cluster_oned";
      }
      QFile f( filename );
      if ( !f.open( QIODevice::WriteOnly ) )
      {
         QMessageBox::information( this,
                                   us_tr( QString( "%1: Save" ).arg( "US-SOMO: 1d cluster interface" ) ),
                                   QString( us_tr( "Could not open file %1 for writing" ) )
                                   .arg( filename ) 
                                   );
         return;
      }
      QTextStream ts( &f );
      ts << US_Json::compose( *parameters );
      f.close();
   }
}

void US_Hydrodyn_Cluster_Oned::load()
{
   QString use_dir = ((US_Hydrodyn *)us_hydrodyn)->somo_dir + QDir::separator() + "cluster" + QDir::separator() + "parameters";
   ((US_Hydrodyn *)us_hydrodyn)->select_from_directory_history( use_dir, this, true );
   QString filename = QFileDialog::getOpenFileName( this , us_tr( "Load parameters" ) , use_dir , "*.cluster_oned" );

   if( !filename.isEmpty() )
   {
      ((US_Hydrodyn *)us_hydrodyn)->add_to_directory_history( filename );
      QFile f( filename );
      if ( !f.open( QIODevice::ReadOnly ) )
      {
          QMessageBox::information( 
                                    this,
                                    us_tr( QString( "%1: Open" ).arg( "US-SOMO: 1d cluster interface" ) ),
                                    QString( us_tr( "Could not open file %1 for reading" ) )
                                    .arg( filename ) 
                                    );
          return;
      }
      QString qs;
      QTextStream ts( &f );
      while ( !ts.atEnd() )
      {
          qs += ts.readLine();
      }
      f.close();
      *parameters = US_Json::split( qs );
      update_fields();
   }
}

void US_Hydrodyn_Cluster_Oned::update_fields()
{
   disconnect( le_1drotationfile, SIGNAL( textChanged( const QString & ) ), 0, 0 );
   le_1drotationfile                               ->setText( parameters->count( "1drotationfile" ) ? ( *parameters )[ "1drotationfile" ] : "" );
   connect( le_1drotationfile, SIGNAL( textChanged( const QString & ) ), SLOT( update_1drotationfile( const QString & ) ) );
   le_1drotationsuserand                           ->setText( parameters->count( "1drotationsuserand" ) ? ( *parameters )[ "1drotationsuserand" ] : "" );
   le_1dlambda                                     ->setText( parameters->count( "1dlambda" ) ? ( *parameters )[ "1dlambda" ] : "" );
   le_1ddetectordistance                           ->setText( parameters->count( "1ddetectordistance" ) ? ( *parameters )[ "1ddetectordistance" ] : "" );
   le_1ddetectorwidth                              ->setText( parameters->count( "1ddetectorwidth" ) ? ( *parameters )[ "1ddetectorwidth" ] : "" );
   le_1ddetectorpixelswidth                        ->setText( parameters->count( "1ddetectorpixelswidth" ) ? ( *parameters )[ "1ddetectorpixelswidth" ] : "" );
   le_1drho0                                       ->setText( parameters->count( "1drho0" ) ? ( *parameters )[ "1drho0" ] : "" );
   le_1ddeltar                                     ->setText( parameters->count( "1ddeltar" ) ? ( *parameters )[ "1ddeltar" ] : "" );
   le_1dproberadius                                ->setText( parameters->count( "1dproberadius" ) ? ( *parameters )[ "1dproberadius" ] : "" );
   le_1dthreshold                                  ->setText( parameters->count( "1dthreshold" ) ? ( *parameters )[ "1dthreshold" ] : "" );
   le_1dsamplerotations                            ->setText( parameters->count( "1dsamplerotations" ) ? ( *parameters )[ "1dsamplerotations" ] : "" );
   le_1daxisrotations                              ->setText( parameters->count( "1daxisrotations" ) ? ( *parameters )[ "1daxisrotations" ] : "" );
   le_1dintermediatesaves                          ->setText( parameters->count( "1dintermediatesaves" ) ? ( *parameters )[ "1dintermediatesaves" ] : "" );
}

