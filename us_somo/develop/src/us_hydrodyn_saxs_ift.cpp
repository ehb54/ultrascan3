// ---------------------------------------------------------------------------------------------
// --------------- WARNING: this code is generated by an automatic code generator --------------
// ---------------------------------------------------------------------------------------------
// -------------- WARNING: any modifications made to this code will be overwritten -------------
// ---------------------------------------------------------------------------------------------

#include "../include/us_hydrodyn_saxs_ift.h"
//Added by qt3to4:
#include <QHBoxLayout>
#include <QCloseEvent>
#include <QGridLayout>
#include <QFrame>
#include <QLabel>

US_Hydrodyn_Saxs_Ift::US_Hydrodyn_Saxs_Ift(
                                           void                     *              us_hydrodyn,
                                           map < QString, QString > *              parameters,
                                           QWidget *                               p,
                                           const char *                            
                                           ) : QDialog( p )
{
   this->us_hydrodyn                          = us_hydrodyn;
   this->parameters                           = parameters;

   USglobal = new US_Config();
   setPalette( PALET_FRAME );
   setWindowTitle( us_tr( "US-SOMO SAXS: IFT" ) );

   setupGUI();

   global_Xpos += 30;
   global_Ypos += 30;

   setGeometry( global_Xpos, global_Ypos, 0, 0 );
   setMinimumWidth( 800 );
}

US_Hydrodyn_Saxs_Ift::~US_Hydrodyn_Saxs_Ift()
{
}

void US_Hydrodyn_Saxs_Ift::cancel()
{
   parameters->clear( );
   close();
}

void US_Hydrodyn_Saxs_Ift::help()
{
   US_Help *online_help;
   online_help = new US_Help( this );
   online_help->show_help("manual/somo/saxs_ift.html");
}

void US_Hydrodyn_Saxs_Ift::closeEvent( QCloseEvent *e )
{
   global_Xpos -= 30;
   global_Ypos -= 30;
   e->accept();
}

void US_Hydrodyn_Saxs_Ift::showhide( vector < QWidget * > & widgets, bool isChecked ) {
   for ( int i = 0; i < (int) widgets.size(); ++i ) {
      isChecked ? widgets[ i ]->show() : widgets[ i ]->hide();
   }
}

void US_Hydrodyn_Saxs_Ift::setupGUI()
{
   QGridLayout * background = new QGridLayout( this ); background->setContentsMargins( 0, 0, 0, 0 ); background->setSpacing( 0 );
   int row = 0;
   int col = 0;
   int colmax = 0;
   lbl_label_0 = new QLabel( us_tr( "Indirect Fourier Transform"), this);
   lbl_label_0->setFrameStyle(QFrame::WinPanel|QFrame::Raised);
   lbl_label_0->setAlignment(Qt::AlignCenter|Qt::AlignVCenter);
   lbl_label_0->setPalette( PALET_FRAME );
   lbl_label_0->setFont(QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1, QFont::Bold));

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_label_0 );
   
#endif

   col = 1 + 1;
   background->addWidget( lbl_label_0 , row , 0 , 1 + ( row ) - ( row ) , 1 + ( col++  ) - ( 0 ) );
   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }


   lbl_qmin = new QLabel( us_tr( " Qmin [Angstrom^-1] :" ), this );
   lbl_qmin->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_qmin->setPalette( PALET_LABEL );
   lbl_qmin->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_qmin );
   lbl_qmin->setToolTip( us_tr( "Optionally enter q min in inverse Angstroms." ) );
#endif

   background->addWidget( lbl_qmin, row, col++ );

   le_qmin = new QLineEdit(this);
   le_qmin->setValidator( new QDoubleValidator( le_qmin ) );
   
   
   
   le_qmin->setText( parameters->count( "qmin" ) ? (*parameters)[ "qmin" ] : "" );
   le_qmin->setEnabled( true );
   le_qmin->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_qmin->setPalette( PALET_NORMAL );
   connect( le_qmin, SIGNAL( textChanged( const QString & ) ), SLOT( update_qmin( const QString & )));

#if QT_VERSION > 0x040000
   le_qmin->setToolTip( us_tr( "Optionally enter q min in inverse Angstroms." ) );
#endif

   background->addWidget( le_qmin, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_qmax = new QLabel( us_tr( " Qmax [Angstrom^-1] :" ), this );
   lbl_qmax->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_qmax->setPalette( PALET_LABEL );
   lbl_qmax->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_qmax );
   lbl_qmax->setToolTip( us_tr( "Qptionally Enter q max in inverse Angstroms." ) );
#endif

   background->addWidget( lbl_qmax, row, col++ );

   le_qmax = new QLineEdit(this);
   le_qmax->setValidator( new QDoubleValidator( le_qmax ) );
   
   
   
   le_qmax->setText( parameters->count( "qmax" ) ? (*parameters)[ "qmax" ] : "" );
   le_qmax->setEnabled( true );
   le_qmax->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_qmax->setPalette( PALET_NORMAL );
   connect( le_qmax, SIGNAL( textChanged( const QString & ) ), SLOT( update_qmax( const QString & )));

#if QT_VERSION > 0x040000
   le_qmax->setToolTip( us_tr( "Qptionally Enter q max in inverse Angstroms." ) );
#endif

   background->addWidget( le_qmax, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   cb_fitbackground = new QCheckBox(this);
   cb_fitbackground->setText( us_tr( "Fit background " ) );
   cb_fitbackground->setChecked( parameters->count( "fitbackground" ) ? ( (*parameters)[ "fitbackground" ] == "true" ? true : false ) : false );
   cb_fitbackground->setEnabled( true );
   cb_fitbackground->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   cb_fitbackground->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   AUTFBACK( cb_fitbackground );
   cb_fitbackground->setToolTip( us_tr( "A constant (flat) background is fitted to the data." ) );
#endif

   connect( cb_fitbackground, SIGNAL( clicked() ), SLOT( set_fitbackground() ) );

   if ( col == 0 ) {
       background->addWidget( cb_fitbackground , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
       col = 2;
   } else {
       background->addWidget( cb_fitbackground, row, col++ );
   }

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_dmax = new QLabel( us_tr( " Maximum diameter [Angstrom] :" ), this );
   lbl_dmax->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_dmax->setPalette( PALET_LABEL );
   lbl_dmax->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_dmax );
   lbl_dmax->setToolTip( us_tr( "Optionally enter starting value for the maximum diameter of the scatterer in Angstroms." ) );
#endif

   background->addWidget( lbl_dmax, row, col++ );

   le_dmax = new QLineEdit(this);
   le_dmax->setValidator( new QDoubleValidator( le_dmax ) );
   ( (QDoubleValidator *)le_dmax->validator() )->setBottom( 0 );
   
   
   le_dmax->setText( parameters->count( "dmax" ) ? (*parameters)[ "dmax" ] : "" );
   le_dmax->setEnabled( true );
   le_dmax->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_dmax->setPalette( PALET_NORMAL );
   connect( le_dmax, SIGNAL( textChanged( const QString & ) ), SLOT( update_dmax( const QString & )));

#if QT_VERSION > 0x040000
   le_dmax->setToolTip( us_tr( "Optionally enter starting value for the maximum diameter of the scatterer in Angstroms." ) );
#endif

   background->addWidget( le_dmax, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 10 ) {
      row++;
      col = 0;
   }

   
   cb_dmaxfixed = new QCheckBox(this);
   cb_dmaxfixed->setText( us_tr( "Fix " ) );
   cb_dmaxfixed->setChecked( parameters->count( "dmaxfixed" ) ? ( (*parameters)[ "dmaxfixed" ] == "true" ? true : false ) : false );
   cb_dmaxfixed->setEnabled( true );
   cb_dmaxfixed->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   cb_dmaxfixed->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   AUTFBACK( cb_dmaxfixed );
   cb_dmaxfixed->setToolTip( us_tr( "Fix the defined maximum diameter" ) );
#endif

   connect( cb_dmaxfixed, SIGNAL( clicked() ), SLOT( set_dmaxfixed() ) );

   if ( col == 0 ) {
       background->addWidget( cb_dmaxfixed , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
       col = 2;
   } else {
       background->addWidget( cb_dmaxfixed, row, col++ );
   }

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_alpha = new QLabel( us_tr( " Starting value for the Lagrange multiplier (Alpha) :" ), this );
   lbl_alpha->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_alpha->setPalette( PALET_LABEL );
   lbl_alpha->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_alpha );
   lbl_alpha->setToolTip( us_tr( "<p>Optionally enter the starting value for the logarithm of the Lagrange multiplier (usually between -10 and 20).</p><p>Larger values will give smoother distributions or - for the MaxEnt constraint:</p><p>an estimate which is closer to the prior ellipsoid of revolution.</p>" ) );
#endif

   background->addWidget( lbl_alpha, row, col++ );

   le_alpha = new QLineEdit(this);
   le_alpha->setValidator( new QDoubleValidator( le_alpha ) );
   
   
   
   le_alpha->setText( parameters->count( "alpha" ) ? (*parameters)[ "alpha" ] : "" );
   le_alpha->setEnabled( true );
   le_alpha->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_alpha->setPalette( PALET_NORMAL );
   connect( le_alpha, SIGNAL( textChanged( const QString & ) ), SLOT( update_alpha( const QString & )));

#if QT_VERSION > 0x040000
   le_alpha->setToolTip( us_tr( "<p>Optionally enter the starting value for the logarithm of the Lagrange multiplier (usually between -10 and 20).</p><p>Larger values will give smoother distributions or - for the MaxEnt constraint:</p><p>an estimate which is closer to the prior ellipsoid of revolution.</p>" ) );
#endif

   background->addWidget( le_alpha, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 10 ) {
      row++;
      col = 0;
   }

   
   cb_alphafixed = new QCheckBox(this);
   cb_alphafixed->setText( us_tr( "Fix " ) );
   cb_alphafixed->setChecked( parameters->count( "alphafixed" ) ? ( (*parameters)[ "alphafixed" ] == "true" ? true : false ) : false );
   cb_alphafixed->setEnabled( true );
   cb_alphafixed->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   cb_alphafixed->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   AUTFBACK( cb_alphafixed );
   cb_alphafixed->setToolTip( us_tr( "Fix the Lagrange multiplier" ) );
#endif

   connect( cb_alphafixed, SIGNAL( clicked() ), SLOT( set_alphafixed() ) );

   if ( col == 0 ) {
       background->addWidget( cb_alphafixed , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
       col = 2;
   } else {
       background->addWidget( cb_alphafixed, row, col++ );
   }

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_smearing = new QLabel( us_tr( " Desmearing constant :" ), this );
   lbl_smearing->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_smearing->setPalette( PALET_LABEL );
   lbl_smearing->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_smearing );
   lbl_smearing->setToolTip( us_tr( "<p>Optionally enter a correction for slit smearing. Default is no smearing.</p><p>Enter value for constant c as given by the expression</p><p>I_smear(q) = integrate P(t)*I(sqrt(q**2 + t**2)) dt with the</p><p>primary beam length profile: P(t) = c/sqrt(pi) * exp(-c**2*t**2).</p><p>The fit and the deconvolution are both given in the ouput file fit.d</p>" ) );
#endif

   background->addWidget( lbl_smearing, row, col++ );

   le_smearing = new QLineEdit(this);
   le_smearing->setValidator( new QDoubleValidator( le_smearing ) );
   
   
   
   le_smearing->setText( parameters->count( "smearing" ) ? (*parameters)[ "smearing" ] : "" );
   le_smearing->setEnabled( true );
   le_smearing->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_smearing->setPalette( PALET_NORMAL );
   connect( le_smearing, SIGNAL( textChanged( const QString & ) ), SLOT( update_smearing( const QString & )));

#if QT_VERSION > 0x040000
   le_smearing->setToolTip( us_tr( "<p>Optionally enter a correction for slit smearing. Default is no smearing.</p><p>Enter value for constant c as given by the expression</p><p>I_smear(q) = integrate P(t)*I(sqrt(q**2 + t**2)) dt with the</p><p>primary beam length profile: P(t) = c/sqrt(pi) * exp(-c**2*t**2).</p><p>The fit and the deconvolution are both given in the ouput file fit.d</p>" ) );
#endif

   background->addWidget( le_smearing, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_prpoints = new QLabel( us_tr( " Number of points in p(r) :" ), this );
   lbl_prpoints->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_prpoints->setPalette( PALET_LABEL );
   lbl_prpoints->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_prpoints );
   lbl_prpoints->setToolTip( us_tr( "<p>Optionally enter the number of points in the estimated function p(r): more points increase the cpu-time.</p><p>Default: 50, Maximum 500</p>" ) );
#endif

   background->addWidget( lbl_prpoints, row, col++ );

   le_prpoints = new QLineEdit(this);
   le_prpoints->setValidator( new QIntValidator( le_prpoints ) );
   ( (QIntValidator *)le_prpoints->validator() )->setBottom( 10 );
   ( (QIntValidator *)le_prpoints->validator() )->setTop( 500 );
   le_prpoints->setText( parameters->count( "prpoints" ) ? (*parameters)[ "prpoints" ] : "" );
   le_prpoints->setEnabled( true );
   le_prpoints->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_prpoints->setPalette( PALET_NORMAL );
   connect( le_prpoints, SIGNAL( textChanged( const QString & ) ), SLOT( update_prpoints( const QString & )));

#if QT_VERSION > 0x040000
   le_prpoints->setToolTip( us_tr( "<p>Optionally enter the number of points in the estimated function p(r): more points increase the cpu-time.</p><p>Default: 50, Maximum 500</p>" ) );
#endif

   background->addWidget( le_prpoints, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_noextracalc = new QLabel( us_tr( " Number of extra error calculations :" ), this );
   lbl_noextracalc->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_noextracalc->setPalette( PALET_LABEL );
   lbl_noextracalc->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_noextracalc );
   lbl_noextracalc->setToolTip( us_tr( "<p>Optionally Input number of extra error calculations (max 1000).</p><p>Entering a large number will improve the error estimate,</p><p>but require more cpu time.</p><p>In some cases it may be a little tricky to obtain a decent</p><p>error estimate. Try testing a couple of values to see the effect. </p>" ) );
#endif

   background->addWidget( lbl_noextracalc, row, col++ );

   le_noextracalc = new QLineEdit(this);
   le_noextracalc->setValidator( new QIntValidator( le_noextracalc ) );
   ( (QIntValidator *)le_noextracalc->validator() )->setBottom( 10 );
   ( (QIntValidator *)le_noextracalc->validator() )->setTop( 1000 );
   le_noextracalc->setText( parameters->count( "noextracalc" ) ? (*parameters)[ "noextracalc" ] : "" );
   le_noextracalc->setEnabled( true );
   le_noextracalc->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_noextracalc->setPalette( PALET_NORMAL );
   connect( le_noextracalc, SIGNAL( textChanged( const QString & ) ), SLOT( update_noextracalc( const QString & )));

#if QT_VERSION > 0x040000
   le_noextracalc->setToolTip( us_tr( "<p>Optionally Input number of extra error calculations (max 1000).</p><p>Entering a large number will improve the error estimate,</p><p>but require more cpu time.</p><p>In some cases it may be a little tricky to obtain a decent</p><p>error estimate. Try testing a couple of values to see the effect. </p>" ) );
#endif

   background->addWidget( le_noextracalc, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_transform = new QLabel( us_tr( " Transformation/Regularization :" ), this );
   lbl_transform->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_transform->setPalette( PALET_LABEL );
   lbl_transform->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_transform );
   lbl_transform->setToolTip( us_tr( "<p>[D]ebye (default -> returning p(r) with positivity constraint)                                        sin(q*r)/(q*r) * dr</p><p>[N]egative (Debye transformation -> returning p(r) without positivity constraint)       sin(q*r)/(q*r) * dr</p><p>[M]axEnt using an ellipsoid of revolution as prior ( -> p(r) -positivity constraint)       sin(q*r)/(q*r) * dr</p><p>     The axial ratio for the ellipsoid is optimized using the posterior probability.</p><p>     The axial ratio may be initialized or fixed using the box <i>Estimate axial ratio</i></p><p>     (leave the box <i>Fit axial ratio</i> empty).</p><p>[B]essel (for cylindrical scatterers -> cross section distribution)        J_0(q*r)/q * dr</p><p>[C]osine (lamellae -> thickness distribution)                                    cos(q*r)/q**2 * dr</p><p>[S]ize (using spheres only -> size distribution)        (3*sin(q*r)-q*r*cos(q*r))/(q*r)**3)**2 * dr </p>" ) );
#endif
   
   background->addWidget( lbl_transform, row, col++ );

   lb_transform = new QListWidget(this);
   lb_transform->setEnabled( true );
   lb_transform->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   lb_transform->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   lb_transform->setToolTip( us_tr( "<p>[D]ebye (default -> returning p(r) with positivity constraint)                                        sin(q*r)/(q*r) * dr</p><p>[N]egative (Debye transformation -> returning p(r) without positivity constraint)       sin(q*r)/(q*r) * dr</p><p>[M]axEnt using an ellipsoid of revolution as prior ( -> p(r) -positivity constraint)       sin(q*r)/(q*r) * dr</p><p>     The axial ratio for the ellipsoid is optimized using the posterior probability.</p><p>     The axial ratio may be initialized or fixed using the box <i>Estimate axial ratio</i></p><p>     (leave the box <i>Fit axial ratio</i> empty).</p><p>[B]essel (for cylindrical scatterers -> cross section distribution)        J_0(q*r)/q * dr</p><p>[C]osine (lamellae -> thickness distribution)                                    cos(q*r)/q**2 * dr</p><p>[S]ize (using spheres only -> size distribution)        (3*sin(q*r)-q*r*cos(q*r))/(q*r)**3)**2 * dr </p>" ) );
#endif

   connect( lb_transform, SIGNAL( itemSelectionChanged() ), SLOT( set_transform() ) );

   {
       QStringList qsl = QString( "Debye (default -> returning p(r) with positivity constraint)~D~Negative (Debye transformation -> returning p(r) without positivity constraint)~N~MaxEnt using an ellipsoid of revolution as prior ( -> p(r) -positivity constraint)~M~Bessel (for cylindrical scatterers -> cross section distribution)~B~Cosine (lamellae -> thickness distribution)~C~Size (using spheres only -> size distribution)~S" ).split( "~" );
       bool any_selected = false;
       for ( int i = 0; i < (int) qsl.size(); i += 2 ) {
           lb_transform->addItem( qsl[ i ] );
           value_map_transform[ qsl[ i ] ] = qsl[ i + 1 ];
           
       }
       if ( qsl.size() && !any_selected ) {
           lb_transform->item( 0)->setSelected( true );
       }
   }


   background->addWidget( lb_transform, row, col++ );
   if ( colmax < col ) {
      colmax = col;
   }
   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   cb_nondilute = new QCheckBox(this);
   cb_nondilute->setText( us_tr( "Non-dilute solution " ) );
   cb_nondilute->setChecked( parameters->count( "nondilute" ) ? ( (*parameters)[ "nondilute" ] == "true" ? true : false ) : false );
   cb_nondilute->setEnabled( true );
   cb_nondilute->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   cb_nondilute->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   AUTFBACK( cb_nondilute );
   cb_nondilute->setToolTip( us_tr( "Check for non-dilute solutions" ) );
#endif

   connect( cb_nondilute, SIGNAL( clicked() ), SLOT( set_nondilute() ) );

   if ( col == 0 ) {
       background->addWidget( cb_nondilute , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
       col = 2;
   } else {
       background->addWidget( cb_nondilute, row, col++ );
   }

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   
   lbl_eta = new QLabel( us_tr( " Estimate value for volume fraction :" ), this );
   lbl_eta->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_eta->setPalette( PALET_LABEL );
   lbl_eta->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_eta );
   lbl_eta->setToolTip( us_tr( "<p>The exact value entered here may influence the result when the information content of the data is low.</p><p>Start with a small number e.g. 0.01 to avoid numerical instabilities and long cpu times.</p>" ) );
#endif

   background->addWidget( lbl_eta, row, col++ );

   le_eta = new QLineEdit(this);
   le_eta->setValidator( new QDoubleValidator( le_eta ) );
   ( (QDoubleValidator *)le_eta->validator() )->setBottom( 0 );
   
   
   le_eta->setText( parameters->count( "eta" ) ? (*parameters)[ "eta" ] : "" );
   le_eta->setEnabled( true );
   le_eta->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_eta->setPalette( PALET_NORMAL );
   connect( le_eta, SIGNAL( textChanged( const QString & ) ), SLOT( update_eta( const QString & )));

#if QT_VERSION > 0x040000
   le_eta->setToolTip( us_tr( "<p>The exact value entered here may influence the result when the information content of the data is low.</p><p>Start with a small number e.g. 0.01 to avoid numerical instabilities and long cpu times.</p>" ) );
#endif

   background->addWidget( le_eta, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   repeats[ cb_nondilute ].push_back( lbl_eta ); repeats[ cb_nondilute ].push_back( le_eta );
   lbl_fitratio = new QLabel( us_tr( " Fit axial ratio method :" ), this );
   lbl_fitratio->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_fitratio->setPalette( PALET_LABEL );
   lbl_fitratio->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_fitratio );
   lbl_fitratio->setToolTip( us_tr( "Optionally enter the method" ) );
#endif
   
   background->addWidget( lbl_fitratio, row, col++ );

   lb_fitratio = new QListWidget(this);
   lb_fitratio->setEnabled( true );
   lb_fitratio->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   lb_fitratio->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   lb_fitratio->setToolTip( us_tr( "Optionally enter the method" ) );
#endif

   connect( lb_fitratio, SIGNAL( itemSelectionChanged() ), SLOT( set_fitratio() ) );

   {
       QStringList qsl = QString( "No concentration effects~noconceffects~Moment~moment~No~no~Evidence~evidence" ).split( "~" );
       bool any_selected = false;
       for ( int i = 0; i < (int) qsl.size(); i += 2 ) {
           lb_fitratio->addItem( qsl[ i ] );
           value_map_fitratio[ qsl[ i ] ] = qsl[ i + 1 ];
           
       }
       if ( qsl.size() && !any_selected ) {
           lb_fitratio->item( 0)->setSelected( true );
       }
   }


   background->addWidget( lb_fitratio, row, col++ );
   if ( colmax < col ) {
      colmax = col;
   }
   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   repeats[ cb_nondilute ].push_back( lbl_fitratio ); repeats[ cb_nondilute ].push_back( lb_fitratio );
   lbl_estimateratio = new QLabel( us_tr( " Estimate the axial ratio :" ), this );
   lbl_estimateratio->setAlignment( Qt::AlignLeft|Qt::AlignVCenter );
   lbl_estimateratio->setPalette( PALET_LABEL );
   lbl_estimateratio->setFont( QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize, QFont::Bold ) );

#if QT_VERSION > 0x040000
   AUTFBACK( lbl_estimateratio );
   lbl_estimateratio->setToolTip( us_tr( "Optionally enter an estimate of the axial ratio" ) );
#endif

   background->addWidget( lbl_estimateratio, row, col++ );

   le_estimateratio = new QLineEdit(this);
   le_estimateratio->setValidator( new QDoubleValidator( le_estimateratio ) );
   
   
   
   le_estimateratio->setText( parameters->count( "estimateratio" ) ? (*parameters)[ "estimateratio" ] : "" );
   le_estimateratio->setEnabled( true );
   le_estimateratio->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   le_estimateratio->setPalette( PALET_NORMAL );
   connect( le_estimateratio, SIGNAL( textChanged( const QString & ) ), SLOT( update_estimateratio( const QString & )));

#if QT_VERSION > 0x040000
   le_estimateratio->setToolTip( us_tr( "Optionally enter an estimate of the axial ratio" ) );
#endif

   background->addWidget( le_estimateratio, row, col++ );

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 10 ) {
      row++;
      col = 0;
   }

   repeats[ cb_nondilute ].push_back( lbl_estimateratio ); repeats[ cb_nondilute ].push_back( le_estimateratio );
   cb_estimateratiofixed = new QCheckBox(this);
   cb_estimateratiofixed->setText( us_tr( "Fix " ) );
   cb_estimateratiofixed->setChecked( parameters->count( "estimateratiofixed" ) ? ( (*parameters)[ "estimateratiofixed" ] == "true" ? true : false ) : false );
   cb_estimateratiofixed->setEnabled( true );
   cb_estimateratiofixed->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize ) );
   cb_estimateratiofixed->setPalette( PALET_NORMAL );
#if QT_VERSION > 0x040000
   AUTFBACK( cb_estimateratiofixed );
   cb_estimateratiofixed->setToolTip( us_tr( "Fix the estimated axial ratio" ) );
#endif

   connect( cb_estimateratiofixed, SIGNAL( clicked() ), SLOT( set_estimateratiofixed() ) );

   if ( col == 0 ) {
       background->addWidget( cb_estimateratiofixed , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
       col = 2;
   } else {
       background->addWidget( cb_estimateratiofixed, row, col++ );
   }

   if ( colmax < col ) {
      colmax = col;
   }

   if ( 0 == 0 ) {
      row++;
      col = 0;
   }

   repeats[ cb_nondilute ].push_back( cb_estimateratiofixed );
   pb_go = new QPushButton( us_tr( "Process" ), this );
   pb_go->setFont( QFont(USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1 ) );
   pb_go->setPalette( PALET_PUSHB );
   connect( pb_go, SIGNAL( clicked() ), SLOT( go() ) );

#if QT_VERSION > 0x040000
   pb_go->setToolTip( us_tr( "Process the IFT on all curves" ) );
#endif

   if ( 0 == 10 ) {
       if ( col == 0 ) {
           background->addWidget( pb_go , row , 0 , 1 + ( row ) - ( row ) , 1 + ( 1  ) - ( 0 ) );
           col = 2;
       } else {
           background->addWidget( pb_go, row, col++ );
       }

       if ( colmax < col ) {
          colmax = col;
       }

       if ( 0 == 0 ) {
          row++;
          col = 0;
       }
   } else {
       bottom_row_buttons.push_back( pb_go );
   }

   
   pb_help = new QPushButton(us_tr("Help"), this);
   pb_help->setFont(QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1));
   pb_help->setPalette( PALET_PUSHB );
   connect(pb_help, SIGNAL(clicked()), SLOT(help()));

   pb_cancel = new QPushButton(us_tr("Close"), this);
   pb_cancel->setFont(QFont( USglobal->config_list.fontFamily, USglobal->config_list.fontSize + 1));
   pb_cancel->setPalette( PALET_PUSHB );
   connect(pb_cancel, SIGNAL(clicked()), SLOT(cancel()));

   {
      QHBoxLayout * hbl = new QHBoxLayout(); hbl->setContentsMargins( 0, 0, 0, 0 ); hbl->setSpacing( 0 );
      hbl->addWidget( pb_help );
      hbl->addWidget( pb_cancel );
      for ( int i = 0; i < (int) bottom_row_buttons.size(); ++i ) {
         hbl->addWidget( bottom_row_buttons[ i ] );
      }

      background->addLayout( hbl , row , 0 , 1 + ( row ) - ( row ) , 1 + ( colmax - 1  ) - ( 0 ) );
   }

   for ( map < QWidget *, vector < QWidget * > >::iterator it = repeats.begin();
         it != repeats.end();
         it++ ) {
      showhide( it->second, ((QCheckBox* )it->first)->isChecked() );
   }
}

void US_Hydrodyn_Saxs_Ift::update_qmin( const QString & str )
{
   (*parameters)[ "qmin" ] = str;
}

void US_Hydrodyn_Saxs_Ift::update_qmax( const QString & str )
{
   (*parameters)[ "qmax" ] = str;
}

void US_Hydrodyn_Saxs_Ift::set_fitbackground()
{
   (*parameters)[ "fitbackground" ] = cb_fitbackground->isChecked() ? "true" : "false";
   
}

void US_Hydrodyn_Saxs_Ift::update_dmax( const QString & str )
{
   (*parameters)[ "dmax" ] = str;
}

void US_Hydrodyn_Saxs_Ift::set_dmaxfixed()
{
   (*parameters)[ "dmaxfixed" ] = cb_dmaxfixed->isChecked() ? "true" : "false";
   
}

void US_Hydrodyn_Saxs_Ift::update_alpha( const QString & str )
{
   (*parameters)[ "alpha" ] = str;
}

void US_Hydrodyn_Saxs_Ift::set_alphafixed()
{
   (*parameters)[ "alphafixed" ] = cb_alphafixed->isChecked() ? "true" : "false";
   
}

void US_Hydrodyn_Saxs_Ift::update_smearing( const QString & str )
{
   (*parameters)[ "smearing" ] = str;
}

void US_Hydrodyn_Saxs_Ift::update_prpoints( const QString & str )
{
   (*parameters)[ "prpoints" ] = str;
}

void US_Hydrodyn_Saxs_Ift::update_noextracalc( const QString & str )
{
   (*parameters)[ "noextracalc" ] = str;
}

void US_Hydrodyn_Saxs_Ift::set_transform()
{
   (*parameters)[ "transform" ] =
#if QT_VERSION < 0x040000
                  value_map_transform.count( lb_transform->currentItem()->text() ) ?
                  value_map_transform[ lb_transform->currentItem()->text() ] :
#else
                 !lb_transform->selectedItems().isEmpty() &&
                  value_map_transform.count( lb_transform->selectedItems().first()->text() ) ?
                  value_map_transform[  lb_transform->selectedItems().first()->text() ] :
#endif
                  ""
                  ;
}

void US_Hydrodyn_Saxs_Ift::set_nondilute()
{
   (*parameters)[ "nondilute" ] = cb_nondilute->isChecked() ? "true" : "false";
   showhide( repeats[ cb_nondilute ], cb_nondilute->isChecked() );
}

void US_Hydrodyn_Saxs_Ift::update_eta( const QString & str )
{
   (*parameters)[ "eta" ] = str;
}

void US_Hydrodyn_Saxs_Ift::set_fitratio()
{
   (*parameters)[ "fitratio" ] =
#if QT_VERSION < 0x040000
                  value_map_fitratio.count( lb_fitratio->currentItem()->text() ) ?
                  value_map_fitratio[ lb_fitratio->currentItem()->text() ] :
#else
                 !lb_fitratio->selectedItems().isEmpty() &&
                  value_map_fitratio.count( lb_fitratio->selectedItems().first()->text() ) ?
                  value_map_fitratio[  lb_fitratio->selectedItems().first()->text() ] :
#endif
                  ""
                  ;
}

void US_Hydrodyn_Saxs_Ift::update_estimateratio( const QString & str )
{
   (*parameters)[ "estimateratio" ] = str;
}

void US_Hydrodyn_Saxs_Ift::set_estimateratiofixed()
{
   (*parameters)[ "estimateratiofixed" ] = cb_estimateratiofixed->isChecked() ? "true" : "false";
   
}

void US_Hydrodyn_Saxs_Ift::go()
{
    (*parameters)[ "button" ] = "go";
    close();
}

